{"body": [{"indent": 0, "text": ["IsoOffset"], "type": "title", "extent": [0, 14], "level": 0}, {"indent": 0, "type": "summary", "extent": [124, 171], "text": ["Builds an offset surface from geometry."]}, {"indent": 0, "type": "para", "extent": [171, 348], "text": ["The IsoOffset operation builds an implicit function given the input\ngeometry. It then uses the implicit function to create a shell at a\nfixed offset from the original surface."]}, {"indent": 0, "type": "para", "extent": [348, 463], "text": ["The tetrahedral mesh mode may be used to create a uniformly sampled\narray of tetrahedrons for use in simulations."]}, {"indent": 0, "type": "para", "extent": [463, 588], "text": ["The volume output modes allow the implicit function to be output\ndirectly as a volume primitive without further processing."]}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [609, 673], "text": ["Controls what is done with the implicit surface generated."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [690, 797], "text": ["A polygonal mesh will be created along the specified\n        offset of the implicit function."]}], "indent": 4, "type": "dt", "extent": [673, 690], "text": ["Iso Surface"]}, {"body": [{"indent": 8, "type": "para", "extent": [813, 996], "text": ["The volume primitive will be set to 1 inside the object\n        and 0 outside the object.  Boundary cells will have an\n        interpolated value between these extremes."]}], "indent": 4, "type": "dt", "extent": [797, 813], "text": ["Fog Volume"]}, {"body": [{"indent": 8, "type": "para", "extent": [1012, 1614], "text": ["The volume primitive will be a Signed Distance Field.\n        Inside the object will store negative numbers storing the\n        distance to the nearest point on the surface.  Outside the\n        object will store positive numbers storing the distance to\n        the nearest point on the primitive.  In the GL display,\n        these tend to look inverted as the exterior is what\n        renders as opaque.  SDFs are also used by the ", {"text": ["RBD Solver"], "fullpath": "/nodes/dop/rbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdsolver"}, " and the ", {"text": ["Fluid Solver"], "fullpath": "/nodes/dop/fluidsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/fluidsolver"}, ". For additional information, see the ", {"text": ["Volume Sample VOP"], "fullpath": "/nodes/vop/volumesample", "scheme": "Node", "type": "link", "value": "/nodes/vop/volumesample"}, " help."]}], "indent": 4, "type": "dt", "extent": [996, 1012], "text": ["SDF Volume"]}, {"body": [{"indent": 8, "type": "para", "extent": [1630, 1784], "text": ["The interior of the object is filled with tetrahedrons.\n        The resulting mesh can be used for deformers or for\n        softbody approaches."]}], "indent": 4, "type": "dt", "extent": [1614, 1630], "text": ["Tetra Mesh"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Output"], "role": "item", "extent": [600, 609], "type": "parameters_item"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [1836, 1985], "text": ["A mesh of tetrahedrons is built within the \"inside\" of the\n        field. This regular mesh is ideal for use in softbody\n        dynamics. "]}, {"body": [{"body": [{"indent": 12, "type": "para", "extent": [1999, 2078], "text": ["The tetrahedrons share faces, so do not have well defined normals."]}], "indent": 8, "role": "item", "type": "note", "extent": [1985, 1999]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 4, "type": "dt", "extent": [1816, 1836], "text": ["Tetra Skeleton"]}, {"body": [{"indent": 8, "type": "para", "extent": [2095, 2307], "text": ["A mesh of individual tetrahedrons is built within the\n        \"inside\" of the field. These tetrahedrons do not share\n        points or faces, so can be split up for various fracturing\n        operations."]}], "indent": 4, "type": "dt", "extent": [2078, 2095], "text": ["Tetra Solid"]}, {"body": [{"indent": 8, "type": "para", "extent": [2318, 2483], "text": ["Builds a mesh of individual cubes inside the field. These\n        cubes do not share faces or points, so can be split up for\n        fracturing operations."]}], "indent": 4, "type": "dt", "extent": [2307, 2318], "text": ["Cubes"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Tetra Type"], "role": "item", "attrs": {"id": "tetratype"}, "extent": [1784, 1796], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2504, 2589], "text": ["Governs the method that will be used to generate the signed\n    distance field."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [2608, 2862], "text": ["Rays will be fired at the geometry from various directions\n        to determine where the surface is. The resulting field will\n        be signed, so an offset of 0 will generate an iso surface\n        separating the inside from the outside."]}], "indent": 4, "type": "dt", "extent": [2589, 2608], "text": ["Ray Intersect"]}, {"body": [{"indent": 8, "type": "para", "extent": [2878, 3315], "text": ["The ", {"text": ["Ray Intersect"], "type": "ui"}, " method determines if voxels are inside or\n        outside the object by sending rays. This can result in leaks\n        and other problems. If you are building an SDF from a\n        collection of metaballs, you can instead determine\n        inside/outside by looking at the metaball field. That is\n        what this method uses. Note that Laser Scanning is likely\n        unwanted when this method is used."]}], "indent": 4, "type": "dt", "extent": [2862, 2878], "text": ["Meta Balls"]}, {"body": [{"indent": 8, "type": "para", "extent": [3328, 3568], "text": ["Exact minimum point to surface will be found. This is slow,\n        but accurate. The resulting field is not signed, so you can\n        only generate a shell around the geometry. An offset greater\n        than 0 must be specified."]}], "indent": 4, "type": "dt", "extent": [3315, 3328], "text": ["Minimum"]}, {"body": [{"indent": 8, "type": "para", "extent": [3585, 3943], "text": ["Only the points of the incoming geometry are used in\n        constructing the field. If the points have normals, the\n        normals are used to determine sign. Otherwise, the field is\n        unsigned like in the case of Minimum. The ", {"text": ["Scatter SOP"], "fullpath": "/nodes/sop/scatter", "scheme": "Node", "type": "link", "value": "/nodes/sop/scatter"}, " is a\n        good way to create a good collection of points from\n        geometry."]}], "indent": 4, "type": "dt", "extent": [3568, 3585], "text": ["Point Cloud"]}, {"body": [{"indent": 8, "type": "para", "extent": [3961, 4052], "text": ["The geometry\u2019s bounding box is used to create an implicit\n        representation."]}], "indent": 4, "type": "dt", "extent": [3943, 3961], "text": ["Implicit Box"]}, {"body": [{"indent": 8, "type": "para", "extent": [4073, 4167], "text": ["The geometry\u2019s bounding sphere is used to create an\n        implicit representation."]}], "indent": 4, "type": "dt", "extent": [4052, 4073], "text": ["Implicit Sphere"]}, {"body": [{"indent": 8, "type": "para", "extent": [4187, 4236], "text": ["The geometry is represented by a plane."]}, {"body": [{"body": [{"indent": 9, "type": "para", "extent": [4256, 4541], "text": ["The volumes in the incoming gdp are all sampled and the\n         sum of their values used to initialize the signed distance\n         field.  No correction is done after the fact, so the\n         result may not actually be a signed distance field if the\n         input isn\u2019t."]}], "indent": 5, "type": "dt", "extent": [4236, 4256], "text": ["Volume Sample"]}, {"body": [{"indent": 9, "type": "para", "extent": [4569, 4750], "text": ["The same behavior as Volume Sample, but a correction pass\n         is done afterward to make the result a signed distance\n         field using the provided zero crossing."]}], "indent": 5, "type": "dt", "extent": [4541, 4569], "text": ["Rebuild Volume Sample"]}], "container": true, "type": "dt_group"}], "indent": 4, "type": "dt", "extent": [4167, 4187], "text": ["Implicit Plane"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Mode"], "role": "item", "attrs": {"id": "mode"}, "extent": [2483, 2489], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [4756, 4818], "text": ["The name primitive attribute will be set to this value."]}], "indent": 0, "text": ["Name"], "role": "item", "extent": [4750, 4756], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [4836, 5146], "text": ["It is often advantageous to make sure voxels in a volume are\n     cubes.  This option allows the resolution of the volume to be\n     specified without having to worry about matching the size and\n     resolution fields.  This parameter controls which axis is\n     divided into Uniform Sampling Divisions."]}], "indent": 0, "text": ["Uniform Sampling"], "role": "item", "extent": [4818, 4836], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [5169, 5338], "text": ["The number of voxels to divide the ", {"text": ["Uniform Sampling"], "type": "ui"}, " axis into.\n     The other axes will be divided into the number of cells that\n     fit for this voxel size."]}], "indent": 0, "text": ["Uniform Sampling Divs"], "role": "item", "extent": [5146, 5169], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [5353, 5450], "text": ["When using non-uniform voxel cells, each dimensions resolution\n     can be specified here."]}], "indent": 0, "text": ["Sampling Divs"], "role": "item", "extent": [5338, 5353], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [5460, 5599], "text": ["The uniform size of the voxels, when specifying the voxel size directly.  The given sized box will be filled by voxels of this size."]}], "indent": 0, "text": ["Div Size"], "role": "item", "extent": [5450, 5460], "type": "parameters_item"}, {"body": [{"indent": 5, "type": "para", "extent": [5621, 5734], "text": ["The resolution of the output mesh or voxel array can be\n     different from what the input was sampled at."]}], "indent": 0, "text": ["Override Output Divs"], "role": "item", "extent": [5599, 5621], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5764, 6053], "text": ["The number of divisions to evaluate the field at. This can be\n    set to a higher resolution than the field, in which case the\n    field is linearly interpolated for the missing values.  When\n    outputing volumes, this is unused as they are generated at the\n    sampling resolution."]}], "indent": 0, "text": ["Output Divs"], "role": "item", "attrs": {"id": "isodiv"}, "extent": [5734, 5747], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6070, 6545], "text": ["The default bounding box is set to be slightly larger than the\n    incoming geometry. If you want to do a large offset, or ensure\n    that the polygonization is stable over changing input geometry,\n    override the bounds to something else. If\n    ", {"text": ["Force Bounds"], "type": "ui"}, " is on it is assumed that the geometry will fit\n    entirely within these bounds.  If a second input is specified,\n    the bounding box of that input will be used rather than the\n    bounds specified here."]}], "indent": 0, "text": ["Override Bounds"], "role": "item", "extent": [6053, 6070], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6557, 6736], "text": ["Slightly increase the specified bounds to ensure there is a\n    layer of voxels outside of the specified boundary.  This can\n    ensure that there are proper outside voxels."]}], "indent": 0, "text": ["Pad Bounds"], "role": "item", "extent": [6545, 6557], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6751, 6843], "text": ["The minimum clipping plane boundary for field evaluation and\n    surface construction."]}], "indent": 0, "text": ["Minimum Bound"], "role": "item", "extent": [6736, 6751], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6858, 6950], "text": ["The maximum clipping plane boundary for field evaluation and\n    surface construction."]}], "indent": 0, "text": ["Maximum Bound"], "role": "item", "extent": [6843, 6858], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6958, 7094], "text": ["The offset to build the iso surface on. The resulting surface\n    will describe points at this distance from the original surface."]}], "indent": 0, "text": ["Offset"], "role": "item", "extent": [6950, 6958], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [7114, 7254], "text": ["Creates the iso surface as a polygon soup primitive instead of creating separate polygon primitives when the output is an iso surface."]}], "indent": 0, "text": ["Build Polygon Soup"], "role": "item", "extent": [7094, 7114], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [7265, 7499], "text": ["The tolerance to use for building the SDF. This affects the ray\n    intersection code. This tolerance is multiplied by the maximum\n    bounding box size of the original geometry, so normally is\n    independent of geometry scale."]}], "indent": 0, "text": ["Tolerance"], "role": "item", "extent": [7254, 7265], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [7531, 7604], "text": ["The ", {"text": ["Laser Scan"], "type": "ui"}, " mode only applies to the ", {"text": ["Ray Intersect"], "type": "ui"}, " mode."]}, {"indent": 4, "type": "para", "extent": [7604, 7831], "text": ["In laser scan mode the SDF is build by sending rays along the\n    primary axes. Only the closest and farthest intersection is\n    used. The space between these two points is classified as\n    inside, and the rest outside."]}, {"indent": 4, "type": "para", "extent": [7831, 8064], "text": ["The laser scan mode will work even with geometry which has\n    poorly defined normals, self intersects, or isn\u2019t fully\n    watertight. The disadvantage is that interior features can\u2019t be\n    represented as they aren\u2019t detected."]}, {"indent": 4, "type": "para", "extent": [8064, 8515], "text": ["When laser scanning is turned off, the SDF is still built by\n    sending rays along the primary axes. However, all intersections are\n    found. Each pair of intersections is tested to see if\n    the segment is inside or outside. This relies on the normal of\n    the geometry being well defined (ie: manifold, no self\n    intersections), and the geometry being watertight. However, complicated\n    shapes with holes can be accurately represented."]}], "indent": 0, "text": ["Laser Scan"], "role": "item", "attrs": {"id": "laserscan"}, "extent": [7499, 7511], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [8526, 8795], "text": ["Even with the best made geometry, numerical imprecision can\n    result in incorrect sign choices. This option will cause the SDF\n    to be post-processed to look for inconsistent signs. These are\n    then made consistent, usually plugging leaks and filling holes."]}, {"body": [{"indent": 5, "type": "para", "extent": [8913, 8924], "text": ["NOTE:"]}], "indent": 4, "type": "para", "extent": [8795, 8913], "text": ["This takes time, however, so can be turned off in cases where\n    the SDF is known to generate without problems."]}, {"body": [{"indent": 5, "type": "para", "extent": [8984, 9061], "text": ["features in the SDF as they may be considered inconsistent\n     signs."]}], "indent": 4, "type": "para", "extent": [8924, 8984], "text": ["Due to the nature of ", {"text": ["Fix Signs"], "type": "ui"}, " it also rounds sharp"]}], "indent": 0, "text": ["Fix Signs"], "role": "item", "extent": [8515, 8526], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [9075, 9437], "text": ["The ", {"text": ["Fix Signs"], "type": "ui"}, " method alone will smooth out, and usually\n    eliminate, sign inversions. However, it is possible for regions\n    of wrong-sign to become stabilized at the boundary of the SDF.\n    This option will force all voxels on the boundary to be marked\n    as exterior. The ", {"text": ["Fix Signs"], "type": "ui"}, " will be much less likely to stabilize\n    incorrectly then."]}], "indent": 0, "text": ["Force Bounds"], "role": "item", "extent": [9061, 9075], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [9450, 9772], "text": ["If one wants a hollow box, one method is to build one box inside\n    the other and not use ", {"text": ["Laser Scanning"], "type": "ui"}, ". A more robust method is to\n    just specify the inner box and use sign inversion. This treats\n    everything outside of the box as inside, allowing the more\n    robust ", {"text": ["Laser Scanning"], "type": "ui"}, " method to be used."]}], "indent": 0, "text": ["Invert Sign"], "role": "item", "extent": [9437, 9450], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [9810, 10031], "text": ["The Point Cloud mode finds this number of nearest points and\n    uses them to determine the local surface properties. A higher\n    number of neighbor will smooth out local variations and create\n    a smoother field."]}], "indent": 0, "text": ["Num Neighbour"], "role": "item", "attrs": {"id": "numneighbour"}, "extent": [9772, 9787], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [10053, 10299], "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."]}, {"indent": 4, "type": "para", "extent": [10299, 10779], "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."]}], "indent": 0, "text": ["Sign Sweep Threshold"], "role": "item", "extent": [10031, 10053], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [10801, 11076], "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."]}], "indent": 0, "text": ["Max Sign Sweep Count"], "role": "item", "extent": [10779, 10801], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11087, 11268], "text": ["The IsoOffset SOP can be used to load and save SDFs from disk\n    rather than always having to recalculate them. The File Mode\n    determines what, if any, disk access occurs."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [11283, 11400], "text": ["If the file does not exist, the file will be written.\n        Otherwise, the SDF will be read from the file."]}], "indent": 4, "type": "dt", "extent": [11268, 11283], "text": ["Automatic"]}, {"body": [{"indent": 8, "type": "para", "extent": [11416, 11581], "text": ["The file will be read. The input geometry will only be used\n        to determine the bounding box (if override bounds is off)\n        and otherwise ignored."]}], "indent": 4, "type": "dt", "extent": [11400, 11416], "text": ["Read Files"]}, {"body": [{"indent": 8, "type": "para", "extent": [11598, 11710], "text": ["The SDF will be calculated from the input geometry and the\n        result saved in the given file name."]}], "indent": 4, "type": "dt", "extent": [11581, 11598], "text": ["Write Files"]}, {"body": [{"indent": 8, "type": "para", "extent": [11728, 11887], "text": ["No file access will occur. The SDF will be generated from\n        the input geometry and then discarded after the result\n        geometry is created."]}], "indent": 4, "type": "dt", "extent": [11710, 11728], "text": ["No Operation"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["File Mode"], "role": "item", "extent": [11076, 11087], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11898, 12162], "text": ["The name of the file to save the SDF representation to. If the\n    extension is .simdata, it will be saved in a format readable by\n    the File DOP. If it is saved in .sdf, it will be saved in the\n    .sdf format. Behavior with other extensions is undefined."]}], "indent": 0, "text": ["File Name"], "role": "item", "extent": [11887, 11898], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [588, 600], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [12179, 12238], "text": ["The geometry to convert into an SDF and then rebuild."]}], "indent": 0, "type": "dt", "extent": [12170, 12179], "text": ["Source"]}, {"body": [{"indent": 4, "type": "para", "extent": [12256, 12343], "text": ["The geometry to use for the bounding box if ", {"text": ["Override Bounds"], "type": "ui"}, " is\n    specified."]}], "indent": 0, "type": "dt", "extent": [12238, 12256], "text": ["Reference Bounds"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "extent": [12162, 12170], "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [12352, 12370], "text": [{"text": "", "fullpath": "/nodes/sop/iso", "scheme": "Node", "type": "link", "value": "/nodes/sop/iso"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [12370, 12391], "text": [{"text": "", "fullpath": "/nodes/sop/scatter", "scheme": "Node", "type": "link", "value": "/nodes/sop/scatter"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [12391, 12459], "text": [{"text": ["How to convert an object into smoke"], "fullpath": "/pyro/convertobjecttosmoke", "scheme": null, "type": "link", "value": "/pyro/convertobjecttosmoke"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [12343, 12352], "container": true, "type": "related_section", "id": "related"}], "summary": ["Builds an offset surface from geometry."], "type": "root", "attrs": {"version": null, "tags": "create, dynamics, model, surface", "namespace": null, "internal": "isooffset", "context": "sop", "type": "node", "icon": "SOP/isooffset"}, "title": ["IsoOffset"]}