{"body": [{"indent": 0, "text": ["Normal"], "type": "title", "extent": [0, 11], "level": 0}, {"indent": 0, "type": "summary", "extent": [108, 150], "text": ["Computes surface normal attribute."]}, {"body": [{"indent": 0, "type": "para", "extent": [165, 336], "text": ["This node computes point, vertex, primitive, or detail normals using a more accurate approach than the ", {"text": ["Facet node"], "fullpath": "/nodes/sop/facet", "scheme": "Node", "type": "link", "value": "/nodes/sop/facet"}, "\nor the ", {"text": ["Vertex node"], "fullpath": "/nodes/sop/vertex", "scheme": "Node", "type": "link", "value": "/nodes/sop/vertex"}, "."]}, {"indent": 0, "type": "para", "extent": [336, 733], "text": ["Unlike the ", {"text": ["Vertex node"], "fullpath": "/nodes/sop/vertex", "scheme": "Node", "type": "link", "value": "/nodes/sop/vertex"}, ", it supports computing vertex normals for polygon soup primitives\nthat were created with a ", {"text": ["PolySoup node"], "fullpath": "/nodes/sop/polysoup", "scheme": "Node", "type": "link", "value": "/nodes/sop/polysoup"}, " having the ", {"text": ["Merge Identical Vertices"], "type": "ui"}, " option disabled.  Existing polygon soup\nprimitives can be passed through a ", {"text": ["PolySoup node"], "fullpath": "/nodes/sop/polysoup", "scheme": "Node", "type": "link", "value": "/nodes/sop/polysoup"}, " with ", {"text": ["Merge Identical Vertices"], "type": "ui"}, " disabled to ensure that vertices are unmerged."]}, {"body": [{"body": [], "indent": 0, "text": ["Edge smoothness"], "role": "item", "attrs": {"id": "116797433"}, "extent": [733, 756], "type": "vimeo"}], "container": true, "role": "item_group", "type": "vimeo_group"}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [150, 165], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [812, 889], "text": ["The subset of geometry whose normal attribute, ", {"text": ["N"], "type": "code"}, ", should be modified."]}, {"indent": 4, "type": "para", "extent": [889, 1543], "text": ["This can be a point, vertex, primitive, or edge group.  If necessary, it will be expanded to a point, vertex, or primitive group, depending on the value of ", {"text": ["Add Normals to"], "type": "ui"}, ".\n    If the input geometry doesn\u2019t have a normal attribute and ", {"text": ["Add Normals to"], "type": "ui"}, " is set to ", {"text": ["Vertices"], "type": "ui"}, ", completely smooth vertex normals, as if Cusp Angle were 180,\n    will be computed over all vertices first, and then normals will be computed for the group as specified.  If the input geometry doesn\u2019t have a normal attribute and\n    ", {"text": ["Add Normals to"], "type": "ui"}, " is set to anything else, this group will be ignored and normals will be computed for all relevant geometry elements."]}], "indent": 0, "text": ["Group"], "role": "item", "attrs": {"id": "group"}, "extent": [788, 796], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [1575, 1624], "text": ["The type of group that ", {"text": ["Group"], "type": "ui"}, " specifies."]}, {"indent": 4, "type": "para", "extent": [1624, 1761], "text": ["If ", {"text": ["Guess from Group"], "type": "ui"}, " is specified and the group type is ambiguous, the guess is made that ", {"text": ["Group"], "type": "ui"}, " specifies a primitive group."]}], "indent": 0, "text": ["Group Type"], "role": "item", "attrs": {"id": "grouptype"}, "extent": [1543, 1555], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [1801, 1860], "text": ["The name of the normal attribute to create or modify."]}], "indent": 0, "text": ["Override Normal"], "role": "item", "attrs": {"id": "normalattrib"}, "extent": [1761, 1778], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [1897, 2066], "text": ["When enabled, a normal attribute will be created or modified based on ", {"text": ["Add Normals to"], "type": "ui"}, ", ", {"text": ["Cusp Angle"], "type": "ui"}, ", and ", {"text": ["Weighting Method"], "type": "ui"}, " for the specified ", {"text": ["Group"], "type": "ui"}, "."]}], "indent": 0, "text": ["Compute Normals"], "role": "item", "attrs": {"id": "docompute"}, "extent": [1860, 1877], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2097, 2176], "text": ["The type of elements to which to add or modify the normal attribute, ", {"text": ["N"], "type": "code"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [2188, 2455], "text": ["Normals will be computed for each point.  This will be the average of the vertex normals around the point, weighted by the vertex angle for\n        each polygon incident to the points, so that, for example, triangulating the surface won\u2019t change the result."]}], "indent": 4, "type": "dt", "extent": [2176, 2188], "text": ["Points"]}, {"body": [{"indent": 8, "type": "para", "extent": [2469, 2704], "text": ["Normals will be computed for each vertex.  If normals of vertices around a single point are less than ", {"text": ["Cusp Angle"], "type": "ui"}, " apart from each other, they will\n        be averaged together, weighted by the vertex angle in each polygon."]}], "indent": 4, "type": "dt", "extent": [2455, 2469], "text": ["Vertices"]}, {"body": [{"indent": 8, "type": "para", "extent": [2720, 2774], "text": ["Normals will be computed for each primitive."]}], "indent": 4, "type": "dt", "extent": [2704, 2720], "text": ["Primitives"]}, {"body": [{"indent": 8, "type": "para", "extent": [2786, 2920], "text": ["A single normal will be computed for the detail, being the average of the primitive normals, weighted by the primitive area."]}], "indent": 4, "type": "dt", "extent": [2774, 2786], "text": ["Detail"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Add Normals to"], "role": "item", "attrs": {"id": "type"}, "extent": [2066, 2082], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2952, 3188], "text": ["When computing vertex normals, if normals of vertices around a single point are less than or equal to this angle (in degrees) apart from each other, they will\n    be averaged together, weighted by the vertex angle in each polygon."]}], "indent": 0, "text": ["Cusp Angle"], "role": "item", "attrs": {"id": "cuspangle"}, "extent": [2920, 2932], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3223, 4022], "text": ["When set to ", {"text": ["By Vertex Angle"], "type": "ui"}, ", care is taken when computing normals to try to avoid issues introduced by sliver polygons and to weight contributions to normals by angle, so that triangulation won\u2019t change normals significantly.\n    When set to ", {"text": ["Each Vertex Equally"], "type": "ui"}, ", a faster, but less accurate, approach similar to the approach used by the ", {"text": ["Facet SOP"], "fullpath": "/nodes/sop/facet", "scheme": "Node", "type": "link", "value": "/nodes/sop/facet"}, ", is used to compute normals, where each vertex is given equal weight around a point, and less checks are done for ensuring stability.\n    When set to ", {"text": ["By Face Area"], "type": "ui"}, ", the behavior is similar to __Each Vertex Equally_, except that vertices on faces with more area will be given more weight when computing point normals.  This is often used to fake the appearance of a smooth bevel for geometry with only a simple chamfer."]}], "indent": 0, "text": ["Weighting Method"], "role": "item", "attrs": {"id": "method"}, "extent": [3188, 3206], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4095, 4430], "text": ["Some points, especially disconnected points, can only generate a zero normal as a normal does not technically make sense for them.  However, often the normal attribute is used for other purposes on these points.  With this option, if the normal computes to zero it will be left unchanged from the input rather than wiping it out."]}], "indent": 0, "text": ["Keep Original Normal Where Computed Normal Is Zero"], "role": "item", "attrs": {"id": "origifzero"}, "extent": [4022, 4074], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4476, 4695], "text": ["When enabled, existing normals in the specified ", {"text": ["Group"], "type": "ui"}, " will be normalized, i.e. each scaled to have length ", {"text": ["1"], "type": "code"}, ".  This is disabled when ", {"text": ["Compute Normals"], "type": "ui"}, " is on, because computed normals are already normalized."]}], "indent": 0, "text": ["Make Normals Unit Length"], "role": "item", "attrs": {"id": "normalize"}, "extent": [4430, 4456], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4730, 4866], "text": ["When enabled, normals in the specified ", {"text": ["Group"], "type": "ui"}, " will have their directions reversed, i.e. the normals will be multiplied by ", {"text": ["-1"], "type": "code"}, "."]}], "indent": 0, "text": ["Reverse Normals"], "role": "item", "attrs": {"id": "reverse"}, "extent": [4695, 4712], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [776, 788], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [4875, 4895], "text": [{"text": "", "fullpath": "/nodes/sop/facet", "scheme": "Node", "type": "link", "value": "/nodes/sop/facet"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [4895, 4916], "text": [{"text": "", "fullpath": "/nodes/sop/vertex", "scheme": "Node", "type": "link", "value": "/nodes/sop/vertex"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [4866, 4875], "container": true, "type": "related_section", "id": "related"}], "summary": ["Computes surface normal attribute."], "type": "root", "attrs": {"version": null, "tags": "vertex", "namespace": null, "bestbet": "normals", "internal": "normal", "context": "sop", "type": "node", "icon": "SOP/normal"}, "title": ["Normal"]}