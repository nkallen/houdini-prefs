{"body": [{"indent": 0, "text": ["Attribute Expression"], "type": "title", "extent": [0, 25], "level": 0}, {"indent": 0, "type": "summary", "extent": [134, 193], "text": ["Allows simple VEX expressions to modify attributes."]}, {"body": [{"indent": 0, "type": "para", "extent": [208, 361], "text": ["This node runs a VEX expression for each point or primitive in the input, and uses the result to set the value of an attribute on the point/primitive."]}, {"indent": 0, "type": "para", "extent": [361, 663], "text": ["This node is faster than the old ", {"fragment": "#point", "text": ["Point SOP which it replaces"], "value": "#point", "fullpath": "/nodes/sop/attribexpression#point", "scheme": null, "type": "link"}, ", because the VEX expression is compiled and can potentially run in parallel. Unlike the Point SOP, this node runs a single VEX expression to generate the attribute value instead of allowing separate expressions for each component."]}, {"indent": 0, "type": "para", "extent": [663, 718], "text": ["For more information on writing VEX expressions, see:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [718, 813], "text": [{"text": ["VEX snippets"], "fullpath": "/vex/snippets", "scheme": null, "type": "link", "value": "/vex/snippets"}, " for information on special syntax in the expression parameter."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [813, 866], "text": ["The full list of ", {"text": ["VEX functions"], "fullpath": "/vex/functions/index", "scheme": null, "type": "link", "value": "/vex/functions/"}, "."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [866, 937], "text": ["The ", {"text": ["VEX chapter"], "fullpath": "/vex/index", "scheme": null, "type": "link", "value": "/vex/"}, " for basic information on the VEX language."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [193, 208], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [983, 1225], "text": ["In Houdini versions prior to 16, the Point SOP was use to modify certain common parameters using HScript expressions. In Houdini 16, trying to put down a Point node creates an Attribute Expression node instead. Why did we make this change?"]}, {"indent": 0, "type": "para", "extent": [1225, 1461], "text": ["The Point node had real advantages of usability and ease of learning. The Point SOP\u2019s use of local variables in simple expressions was a great tool for learning trig and linear algebra for artists. So why have we replaced it with VEX?"]}, {"indent": 0, "type": "para", "extent": [1461, 1733], "text": ["Point SOP had serious performance issues. It worked on vector components separately, limiting possibilities for parallel computation. Worse, it cannot not work with the ", {"text": ["compiled geometry node"], "fullpath": "/model/compile", "scheme": null, "type": "link", "value": "/model/compile"}, " workflow which will be more and more important in the future."]}, {"indent": 0, "type": "para", "extent": [1733, 1870], "text": ["See ", {"fragment": "#why/", "text": ["why VEX and attributes"], "value": "/vex/snippets#why/", "fullpath": "/vex/snippets#why/", "scheme": null, "type": "link"}, " for a discussion on why VEX is the future for ad-hoc geometry manipulation in Houdini."]}], "indent": 0, "level": 2, "text": ["What happened to the Point SOP?"], "extent": [937, 983], "container": true, "type": "h", "id": "point"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [1907, 2004], "text": ["The ", {"text": ["self"], "type": "code"}, " variable is pre-defined as the current (input) attribute value in the expression."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [2004, 2170], "text": ["You can read the values of other attributes on the geometry using ", {"text": ["@", {"text": ["name"], "type": "var"}], "type": "code"}, ". See ", {"fragment": "#attributes", "text": ["reading attributes in snippets"], "value": "/vex/snippets#attributes", "fullpath": "/vex/snippets#attributes", "scheme": null, "type": "link"}, " for more information."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [2170, 2360], "text": ["The ", {"text": ["@elemnum"], "type": "code"}, " (or ", {"text": ["@ptnum"], "type": "code"}, ") pseudo-variable contains the index of the current point or primitive. This is useful as a random number seed to get different random values for each element."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [2360, 2599], "text": ["Use ", {"text": ["@Frame"], "type": "code"}, ", ", {"text": ["@Time"], "type": "code"}, ", or ", {"text": ["@TimeInc"], "type": "code"}, " in the VEX expression to reference the current frame number, time, or time increment. To access other global variables without a VEX equivalent, you can use the ", {"fragment": "#constant", "text": ["Constant value"], "value": "#constant", "fullpath": "/nodes/sop/attribexpression#constant", "scheme": null, "type": "link"}, " parameter."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [2599, 2830], "text": ["Unlike in Wrangle nodes, you do not need to write a complete VEX statement, only a VEX expression. If you need to write a multi-line function, or require control-flow, use an ", {"text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}, " instead."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Writing the expression"], "extent": [1870, 1907], "container": true, "type": "h", "id": "write"}, {"body": [{"indent": 0, "type": "para", "extent": [2867, 3098], "text": ["If the attribute is scalar (a simple ", {"text": ["int"], "type": "code"}, " or ", {"text": ["float"], "type": "code"}, "), the expression can use ", {"text": ["self"], "type": "code"}, " to refer to the current value, and simply compute a single number. For example, to increase the current value on every point, you could write:"]}, {"lang": null, "indent": 0, "type": "pre", "extent": [3098, 3117], "text": ["\nself + 1.0\n"]}, {"indent": 0, "type": "para", "extent": [3117, 3338], "text": ["This expression will work with vector attributes as well: it will add ", {"text": ["1.0"], "type": "code"}, " to each component of the vector. (In general, operators and functions that work on scalar values will work component-wise on vectors as well.)"]}, {"indent": 0, "type": "para", "extent": [3338, 3467], "text": ["However, when working with vector attributes, you will usually need to pull the individual components out of the current value."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [3467, 3695], "text": ["Or, you can simply use the array/vector indexing operator to pull out individual components: ", {"text": ["self[0]"], "type": "code"}, ", ", {"text": ["self[1]"], "type": "code"}, ", ", {"text": ["self[2]"], "type": "code"}, ", and so on. This form is useful when the index of the attribute is itself a variable or expression."]}, {"body": [{"indent": 4, "type": "para", "extent": [3808, 3929], "text": ["Alternatively, you can use ", {"text": ["self.r"], "type": "code"}, ", ", {"text": ["self.g"], "type": "code"}, ", and ", {"text": ["self.b"], "type": "code"}, " (and ", {"text": ["self.a"], "type": "code"}, " in a ", {"text": ["vector4"], "type": "code"}, ") when working with colors."]}], "indent": 0, "text": ["For readability, you can optionally use ", {"text": ["self.x"], "type": "code"}, ", ", {"text": ["self.y"], "type": "code"}, ", and ", {"text": ["self.z"], "type": "code"}, " to access the individual components."], "extent": [3695, 3808], "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [3929, 4087], "text": ["To set individual components, use the ", {"text": ["set()"], "type": "code"}, " function. For example, to half the amount of red and green and double the amount of blue in a color attribute:"]}, {"lang": "vex", "indent": 0, "type": "pre", "extent": [4087, 4147], "text": ["\nset(self.r * 0.5, self.g * 0.5, self.b * 2.0)\n"]}], "indent": 0, "level": 2, "text": ["Working with vectors"], "extent": [2830, 2867], "container": true, "type": "h", "id": "vectors"}, {"body": [{"indent": 0, "type": "para", "extent": [4181, 4434], "text": ["Accessing keyframed values in VEX often requires creating spare parameters and referencing them using a ", {"text": ["ch"], "type": "code"}, " function. This node provides a pre-made ", {"text": ["Constant value"], "type": "ui"}, " parameter for this purpose so you don\u2019t have to create a spare parameter yourself."]}, {"indent": 0, "type": "para", "extent": [4434, 4581], "text": ["You can use HScript expressions or keyframe animation in this parameter, and refer to its value in the VEX expression using the ", {"text": ["value"], "type": "code"}, " variable."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [4587, 4704], "text": ["The value of this parameter is computed ", {"text": ["once"], "type": "em"}, " for the input geometry. It cannot vary for each point/primitive."]}], "indent": 0, "role": "item", "type": "note", "extent": [4581, 4587]}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "extent": [4704, 4828], "text": ["For example, if you need to use the current position of ", {"text": ["geo1"], "type": "code"}, " in the expression, you could set the ", {"text": ["Constant value"], "type": "ui"}, " to:"]}, {"body": [{"body": [{"indent": 0, "text": [{"text": ["ch(\"/obj/geo1/tx\")"], "type": "code"}, " "], "role": "td", "extent": [4828, 4851], "type": "cell"}, {"indent": 4, "text": [{"text": ["ch(\"obj/geo1/ty\")"], "type": "code"}, " "], "role": "td", "extent": [4851, 4877], "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [4877, 4906], "text": [{"text": ["ch(\"obj/geo1/tz\")"], "type": "code"}]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": []}, {"indent": 0, "type": "para", "extent": [4906, 4986], "text": ["Then get the values in the expression as ", {"text": ["value.x"], "type": "code"}, ", ", {"text": ["value.y"], "type": "code"}, ", and ", {"text": ["value.z"], "type": "code"}, "."]}], "indent": 0, "level": 2, "text": ["Constant value"], "extent": [4147, 4181], "container": true, "type": "h", "id": "constant"}, {"body": [{"indent": 0, "type": "para", "extent": [5005, 5073], "text": ["To do a simple random jitter of the points in the input geometry:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "ord", "extent": [5073, 5117], "text": ["Set the ", {"text": ["Attribute class"], "type": "ui"}, " to \"Points\"."]}, {"indent": 0, "blevel": 2, "type": "ord", "extent": [5117, 5161], "text": ["Set the ", {"text": ["Attribute"], "type": "ui"}, " to \"Position (P)\"."]}, {"body": [{"lang": "vex", "indent": 4, "type": "pre", "extent": [5192, 5330], "text": ["\n    set(self.x + rand(@elemnum) - 0.5, self.y + rand(@elemnum * 10) - 0.5, self.z + rand(@elemnum * 100) - 0.5)\n    "]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [5330, 5464], "text": [{"text": ["set()"], "type": "code"}, " returns a vector. This allows us to construct a new vector value based on the components of the current vector value."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5464, 5721], "text": [{"text": ["@elemnum"], "type": "code"}, " is the index of the current point. Here we use it as the seed for the random number generator, so each point will have different numbers. We further modify it (", {"text": ["* 10"], "type": "code"}, " and ", {"text": ["* 100"], "type": "code"}, ") so each component so they will have different numbers."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5721, 5862], "text": [{"text": ["rand()"], "type": "code"}, " generates a number from 0-1. We subtract 0.5 from the value to move each point randomly from -0.5 to +0.5 in each direction."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Set the ", {"text": ["VEXpression"], "type": "ui"}, " to:"], "extent": [5161, 5192], "blevel": 2, "type": "ord"}, {"body": [{"lang": "vex", "indent": 4, "type": "pre", "extent": [5922, 6111], "text": ["\n    set(self.x + (rand(@elemnum) - 0.5) * chf(\"scale\"), self.y + (rand(@elemnum * 10) - 0.5) * chf(\"scale\"), self.z + (rand(@elemnum * 100) - 0.5) * chf(\"scale\"))\n    "]}, {"indent": 4, "type": "para", "extent": [6111, 6353], "text": ["Then, click the ", {"text": "", "fullpath": "/nodes/sop/BUTTONS/create_parm_from_ch", "scheme": "Icon", "type": "link", "value": "BUTTONS/create_parm_from_ch"}, " Create Parameters button to automatically create a ", {"text": ["Scale"], "type": "ui"}, " parameter based on the ", {"text": ["ch()"], "type": "code"}, " references in the expression. You can use this new parameter to scale the jitter effect."]}], "indent": 0, "text": ["You could parameterize the expression by changing it to:"], "extent": [5862, 5922], "blevel": 2, "type": "ord"}], "container": true, "type": "ord_group"}], "indent": 0, "level": 2, "text": ["Example"], "extent": [4986, 5005], "container": true, "type": "h", "id": "eg"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [6381, 6708], "text": ["If you set ", {"text": ["Attribute"], "type": "ui"}, " to \"Custom\" and set the ", {"text": ["Name"], "type": "ui"}, " to an attribute that doesn\u2019t exist, the node will create it. In this case will probably build the expression using the value of other attributes, since ", {"text": ["self"], "type": "code"}, " will be ", {"text": ["0"], "type": "code"}, " (or ", {"text": ["{0, 0, 0}"], "type": "code"}, ", or the empty string, or whatever the \"zero\" value for a given data type is)."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [6708, 6913], "text": ["If you're modifying, for example, the ", {"text": ["P"], "type": "code"}, " (position) attribute, you can use ", {"text": ["@P"], "type": "code"}, " in your expression instead of ", {"text": ["self"], "type": "code"}, ". The only disadvantage is that you can\u2019t re-use the expression elsewhere as easily."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [6913, 7061], "text": ["VEX trigonometry functions use radians, where HScript expression functions use degrees. You can use ", {"text": "", "value": "/vex/functions/radians", "fallback_text": "radians()", "fullpath": "/vex/functions/radians", "scheme": "Vex", "type": "link"}, " to convert degrees to radians."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7061, 7401], "text": ["You can use ", {"text": "", "value": "/vex/functions/ch", "fallback_text": "ch()", "fullpath": "/vex/functions/ch", "scheme": "Vex", "type": "link"}, " functions in the VEX expression to reference parameters on this node. You can then click the ", {"text": "", "fullpath": "/nodes/sop/BUTTONS/create_parm_from_ch", "scheme": "Icon", "type": "link", "value": "BUTTONS/create_parm_from_ch"}, " Create Parameters button to the right of the expression to automatically create parameters based on the ", {"text": ["ch"], "type": "code"}, " calls. This lets you create interactive controls for values in the expression."]}, {"body": [{"indent": 4, "type": "para", "extent": [7776, 7888], "text": ["For example, the following expression would add the sin of the current point number to each component:"]}, {"lang": "vex", "indent": 4, "type": "pre", "extent": [7888, 7946], "text": ["\n    self + sin(radians(@ptnum))\n    "]}, {"indent": 4, "type": "para", "extent": [7946, 8028], "text": ["To modify only the Y component, you could change the expression to:"]}, {"lang": "vex", "indent": 4, "type": "pre", "extent": [8028, 8094], "text": ["\n    self + value * sin(radians(@ptnum))\n    "]}, {"indent": 4, "type": "para", "extent": [8094, 8147], "text": ["\u2026and then set the constant value to:"]}, {"lang": null, "indent": 4, "type": "pre", "extent": [8147, 8175], "text": ["\n    0, 1, 0\n    "]}], "indent": 0, "text": ["If you only want to modify one component of a vector using the expression, you can use a \"trick\" to make it easier. Apply the expression to each component of ", {"text": ["self"], "type": "code"}, " (the ", {"fragment": "#writing", "text": ["current value"], "value": "#writing", "fullpath": "/nodes/sop/attribexpression#writing", "scheme": null, "type": "link"}, "), but multiply the modification by ", {"text": ["value"], "type": "code"}, " (the optional ", {"fragment": "#constant", "text": ["constant value"], "value": "#constant", "fullpath": "/nodes/sop/attribexpression#constant", "scheme": null, "type": "link"}, "). Then set the ", {"text": ["Constant value"], "type": "ui"}, " to, for example, ", {"text": ["0, 1, 0"], "type": "code"}, " to modify only the Y component."], "extent": [7401, 7776], "blevel": 2, "type": "bullet"}, {"body": [{"indent": 4, "type": "para", "extent": [8350, 8480], "text": ["You can open the parameter value in a floating editor window using ", {"keys": ["Ctrl", "E"], "text": null, "type": "keys"}, " to make it slightly easier to work with."]}, {"indent": 4, "type": "para", "extent": [8480, 8635], "text": ["Or, you might find it easier to use an ", {"text": ["Attribute Wrangle node"], "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}, " instead, where you can treat the components on separate lines."]}, {"indent": 4, "type": "para", "extent": [8635, 8682], "text": ["For example, a long expression like this:"]}, {"lang": "vex", "indent": 4, "type": "pre", "extent": [8682, 8820], "text": ["\n    set(self.x + rand(@elemnum) - 0.5, self.y + rand(@elemnum * 10) - 0.5, self.z + rand(@elemnum * 100) - 0.5)\n    "]}, {"indent": 4, "type": "para", "extent": [8820, 8905], "text": ["\u2026becomes easier to work with as separate statements in an Attribute Wrangle:"]}, {"lang": "vex", "indent": 4, "type": "pre", "extent": [8905, 9048], "text": ["\n    @P.x += rand(@elemnum * 1) - 0.5;\n    @P.y += rand(@elemnum * 10) - 0.5;\n    @P.z += rand(@elemnum * 100) - 0.5;\n    "]}], "indent": 0, "text": ["Because the expression is only one line, modifying vector components individually can quickly make the expression long and difficult to work with in the parameter editor."], "extent": [8175, 8350], "blevel": 2, "type": "bullet"}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9048, 9390], "text": ["The node automatically translates your expressions into a full VEX snippet for compilation. This can be useful for debugging, or if the expressions are becoming complicated and you want to copy the generated code into an Attribute Wrangle SOP. To view the generated VEX code, click the ", {"text": ["Generated code"], "type": "ui"}, " tab, then click ", {"text": ["Update code"], "type": "ui"}, "."]}, {"body": [{"indent": 4, "type": "para", "extent": [9548, 9725], "text": ["Note that row/column numbers in the error report refer to the generated code. To view the generated VEX code, click the ", {"text": ["Generated code"], "type": "ui"}, " tab, then click ", {"text": ["Update code"], "type": "ui"}, "."]}], "indent": 0, "text": ["An error in the VEX code will cause the node to error. Press ", {"keys": ["MMB"], "text": null, "type": "keys"}, " on the node to ", {"fragment": "#info", "text": ["view the node info window"], "value": "/network/nodes#info", "fullpath": "/network/nodes#info", "scheme": null, "type": "link"}, " to see the error text."], "extent": [9390, 9548], "blevel": 2, "type": "bullet"}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9725, 9822], "text": ["Unlike the ", {"text": ["Attrib Create SOP"], "fullpath": "/nodes/sop/attribcreate", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcreate"}, ", this node does not use local variables."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9822, 10256], "text": ["This node has multiple inputs so you can pipe other geometry in to reference in the expression. VEX geometry functions generally take an ", {"text": ["input"], "type": "code"}, " as the first argument specifying which input to read geometry data from. To read an attribute from another input, you can prefix the attribute name with ", {"text": ["opinput", {"text": ["num"], "type": "var"}, "_"], "type": "code"}, ", for example ", {"text": ["v@opinput1_P"], "type": "code"}, " (see ", {"fragment": "#attributes", "text": ["reading attributes in snippets"], "value": "/vex/snippets#attributes", "fullpath": "/vex/snippets#attributes", "scheme": null, "type": "link"}, " for more information)."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Tips and notes"], "extent": [6353, 6381], "container": true, "type": "h", "id": "tips"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [10296, 10467], "text": ["Which components this node will affect. This can include ", {"text": ["group"], "fullpath": "/model/groups", "scheme": null, "type": "link", "value": "/model/groups"}, " names and/or component numbers. If this is blank, the node affects all input geometry."]}], "indent": 0, "text": ["Group"], "role": "item", "attrs": {"id": "bindgroup"}, "extent": [10268, 10276], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [10503, 10684], "text": ["If more than one type of group has the same name, or you are using component numbers in the group field, you can manually set which component type the group field should use."]}], "indent": 0, "text": ["Group Type"], "role": "item", "attrs": {"id": "bindgrouptype"}, "extent": [10467, 10479], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [10741, 10836], "text": ["What the type of component to iterate over. For example, points or primitives (polygons)."]}], "indent": 0, "text": ["Attribute Class"], "role": "item", "attrs": {"id": "bindclass"}, "extent": [10703, 10721], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [10886, 10963], "text": ["You can add or remove additional expressions using the + and - buttons."]}], "indent": 0, "text": ["Attribute VEXpressions"], "role": "item", "attrs": {"id": "expressions"}, "extent": [10836, 10860], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [10989, 11123], "text": ["Apply this expression to the input. This is useful for toggling the expression on and off to see its effect on the geometry."]}], "indent": 0, "text": ["Enable"], "role": "item", "attrs": {"id": "enable#"}, "extent": [10963, 10971], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11152, 11257], "text": ["Choose from a list of commonly used attributes, or choose \"Custom\" to enter the attribute name."]}], "indent": 0, "text": ["Attribute"], "role": "item", "attrs": {"id": "preset#"}, "extent": [11123, 11134], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11283, 11361], "text": ["When ", {"text": ["Attribute"], "type": "ui"}, " is \"Custom\", the name of the attribute to modify."]}], "indent": 0, "text": ["Name"], "role": "item", "attrs": {"id": "name#"}, "extent": [11257, 11263], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11383, 11597], "text": ["When ", {"text": ["Attribute"], "type": "ui"}, " is \"Custom\", the type of the attribute to modify. If this does not match the type of the named attribute in the input geometry, the node will not error, but you may get strange results."]}], "indent": 0, "text": ["Type"], "role": "item", "attrs": {"id": "type#"}, "extent": [11361, 11367], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11613, 11885], "text": ["The node computes the value of this parameter and makes it available in the VEX expression as the ", {"text": ["value"], "type": "code"}, " variable. This is useful for grabbing keyframed values and making them available in VEX. See ", {"fragment": "#constant", "text": ["how to use the constant value"], "value": "#constant", "fullpath": "/nodes/sop/attribexpression#constant", "scheme": null, "type": "link"}, " for more information."]}], "indent": 0, "text": ["Constant Value"], "role": "item", "extent": [11597, 11613], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [11921, 12231], "text": ["A VEX expression that generates the new value for the attribute. You can use ", {"text": ["self"], "type": "code"}, " to refer to the input value on the current point/primitive. For a vector attribute, you can generate a new vector using ", {"text": ["set()"], "type": "code"}, ", as in ", {"text": ["set(self.x, self.y., self.z)"], "type": "code"}, ". See the node documentation for more information."]}], "indent": 0, "text": ["VEXpression"], "role": "item", "attrs": {"id": "snippet#"}, "extent": [11885, 11898], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["VEXpressions"], "extent": [10684, 10703], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [12295, 12539], "text": ["Relative paths in VEX functions such as ", {"text": "", "value": "/vex/functions/ch", "fallback_text": "ch()", "fullpath": "/vex/functions/ch", "scheme": "Vex", "type": "link"}, " are relative to this node path. The default value (", {"text": ["."], "type": "code"}, ") makes them relative to this node. This can be useful for embedding in a digital asset if you want paths to be relative to asset root."]}], "indent": 0, "text": ["Evaluation Node Path"], "role": "item", "attrs": {"id": "vex_cwdpath"}, "extent": [12246, 12269], "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "extent": [5655, 6229], "text": ["The ", {"text": ["@opinput", {"text": ["inputnum"], "type": "var"}, "_", {"text": ["name"], "type": "var"}], "type": "code"}, " syntax lets you get the value of an attribute from the corresponding element on another input. If this parameter is blank, the \"corresponding\" element is the element with the same index (e.g. point number) as the element the node is currently processing. If you specify the name of an attribute, the \"corresponding\" element is the element that has the same value in the named attribute as the current element. See ", {"fragment": "#other_inputs", "text": ["accessing attributes from other inputs"], "value": "/vex/snippets#other_inputs", "fullpath": "/vex/snippets#other_inputs", "scheme": null, "type": "link"}, " on the VEX snippets page for more information."]}, {"type": "para", "indent": 4, "extent": [6229, 6475], "text": ["For example, if you used ", {"text": ["id"], "type": "code"}, " as the \"attribute to match\", and you were processing a point with attribute ", {"text": ["id"], "type": "code"}, " set to ", {"text": ["12"], "type": "code"}, ", then ", {"text": ["@opinput1_P"], "type": "code"}, " would give you the ", {"text": ["P"], "type": "code"}, " attribute on the point in the second input that also has ", {"text": ["id"], "type": "code"}, " set to ", {"text": ["12"], "type": "code"}, "."]}], "indent": 0, "text": ["Attribute to Match"], "role": "item", "attrs": {"id": "vex_matchattrib"}, "extent": [5605, 5625], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [12614, 12800], "text": ["Space separated list of files to include in the generated VEX, for example ", {"text": ["voplib.h shading.h"], "type": "code"}, ". You can use this to make your own helper functions available in the expression."]}], "indent": 0, "text": ["Include Files"], "role": "item", "attrs": {"id": "includes"}, "extent": [12576, 12591], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [12858, 13145], "text": ["When ", {"text": ["Attribute class"], "type": "ui"}, " is \"Points\" and you modify the ", {"text": ["P"], "type": "code"}, " (position) attribute and not ", {"text": ["N"], "type": "code"}, ", the normals in the ", {"text": ["N"], "type": "code"}, " attribute will be out-of-date with the new positions. When this option is on, the node automatically updates the vertex and point normals when this occurs."]}], "indent": 0, "text": ["Update Normals If Displaced"], "role": "item", "attrs": {"id": "vex_updatenmls"}, "extent": [12800, 12829], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Bindings"], "extent": [12231, 12246], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [13205, 13429], "text": ["Updates the generated code field based on the expressions on the ", {"text": ["VEXpressions"], "type": "ui"}, " tab. The code display does not update itself, so you should always click this before checking the code to make sure it\u2019s up to date."]}], "indent": 0, "text": ["Update Code"], "role": "item", "attrs": {"id": "updatecode"}, "extent": [13166, 13180], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [13473, 13932], "text": ["Displays the VEX snippet equivalent to the expressions on the ", {"text": ["VEXpressions"], "type": "ui"}, " tab. This can be useful for debugging, or if the expressions are becoming complicated and you want to copy the generated code into an ", {"text": ["Attribute Wrangle SOP"], "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}, ". This is read only: changing it does not affect the node. This field does not update itself, so you should always click ", {"text": ["Update code"], "type": "ui"}, " before checking it to make sure it\u2019s up to date."]}], "indent": 0, "text": ["Generated Code"], "role": "item", "attrs": {"id": "generatedcode"}, "extent": [13429, 13445], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Generated Code"], "extent": [13145, 13166], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [10256, 10268], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [13941, 13971], "text": [{"text": "", "fullpath": "/nodes/sop/groupexpression", "scheme": "Node", "type": "link", "value": "/nodes/sop/groupexpression"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [13971, 13994], "text": [{"text": "", "fullpath": "/nodes/sop/attribvop", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribvop"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [13994, 14022], "text": [{"text": "", "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [13932, 13941], "container": true, "type": "related_section", "id": "related"}], "title": ["Attribute Expression"], "summary": ["Allows simple VEX expressions to modify attributes."], "attrs": {"version": null, "namespace": null, "bestbet": "point", "internal": "attribexpression", "context": "sop", "type": "node", "icon": "SOP/attribexpression"}, "included": ["/nodes/sop/attribvop"], "type": "root"}