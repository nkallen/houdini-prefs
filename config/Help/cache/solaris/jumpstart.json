{"body": [{"indent": 0, "text": ["Solaris Jumpstart"], "type": "title", "extent": [0, 22], "level": 0}, {"indent": 0, "type": "para", "extent": [34, 116], "text": ["A huge thanks to Chris Rydalch for creating this excellent ", {"text": ["Solaris Jumpstart"], "type": "em"}, "."]}, {"body": [{"indent": 0, "type": "para", "extent": [150, 747], "text": ["Universal Scene Description (", {"text": ["USD"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs"}, ") is an open source scene description from Pixar for efficiently building and collaborating on 3D assets and scenes. In Houdini it is implemented in LOPs. Using USD via LOPs allows multiple users/departments to work on the same scene non-destructively. It provides not only a framework for a studio\u2019s pipeline, but the actual infrastructure to provide fast and efficient ways of building, presenting, inspecting, and editing a stage (scene).  USD is ", {"text": [{"text": ["much"], "type": "strong"}], "type": "em"}, " more than just another geometry format like Alembic, OBJ, or FBX."]}, {"indent": 0, "type": "para", "extent": [747, 947], "text": ["Houdini\u2019s lighting and look development context is LOPs, which stands for Lighting Operators.  LOP Networks are similar to SOPs, however instead of using Houdini\u2019s geometry model, LOPs uses USD."]}, {"indent": 0, "type": "para", "extent": [947, 1163], "text": ["USD also introduces a whole new vocabulary, which unfortunately is sometimes at odds with existing Houdini terminology or conventional CG terminology.  Please see the ", {"text": ["glossary"], "fullpath": "/solaris/glossary", "scheme": null, "type": "link", "value": "glossary"}, " for further clarification. "]}, {"indent": 0, "type": "para", "extent": [1163, 1563], "text": ["As a single user or small studio, you might be wondering if LOPs is worth the effort.  If for nothing else, it\u2019s worth exploring so you can use Karma, the Houdini renderer that consumes USD and not traditional IFD files.  However, just as the idea of a pipeline or shot environment might not seem blindingly obvious at first, once you have used it and mastered it, LOPs may become indispensible.  "]}], "indent": 0, "level": 2, "text": ["Universal Scene Description"], "extent": [116, 150], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [1590, 1977], "text": ["When looking at a USD scene, it is a hierarchy made up of primitives that have properties. A ", {"fragment": "#prim", "text": ["Prim"], "value": "glossary#prim", "fullpath": "/solaris/glossary#prim", "scheme": null, "type": "link"}, " can be of several types (USD calls these types schemas), such as Meshes, Lights, Cameras, Shaders, and so on. USD can be extended to support new schemas, but the core library is fairly comprehensive. Each schema defines all of the properties that each prim type supports."]}, {"indent": 0, "type": "para", "extent": [1977, 2353], "text": ["Properties of a prim can be either attributes or relationships. An attribute is simply some sort of value (such as a color, a float, a transform matrix, or an array of values). Attributes can be animated, with each time sample stored in an array. Relationships point to a primitive or property in the scene. Attributes which are not part of the schema are custom attributes."]}, {"indent": 0, "type": "para", "extent": [2353, 2604], "text": ["An important characteristic of USD prims is they cannot be permanently deleted from a composed stage. USD does support deactivation, which is a non-destructive deletion. Activation is another opinion, meaning it will be resolved through composition."]}], "indent": 0, "level": 2, "text": ["Prims and Properties"], "extent": [1563, 1590], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2621, 3158], "text": ["USD provides instancing in two forms. ", {"text": ["Native instancing"], "type": "strong"}, " is a property which will tell USD to generate a single \u201cmaster primitive\u201d in order to efficiently represent many copies of an asset. Native instancing can be set on any primitive, and USD will create \"master primitives\" as necessary. Master primitives get shares between instanceable primitives automatically if USD detects that multiple instanceable prims are \"the same\".  ", {"text": ["Point Instancer"], "type": "strong"}, " is a special schema that allows for representing vast copies of geometry efficiently."]}, {"indent": 0, "type": "para", "extent": [3158, 3395], "text": ["Both types of instances support transforming the top-level of each primitive and they also allow you to author primvars (on the native instance individually, or on the point instancer primitive) to set per-instance material properties."]}, {"indent": 0, "type": "para", "extent": [3395, 3790], "text": [{"text": ["Native instances"], "type": "strong"}, " are actual transforms on each instance, and each instance is represented in the scene as unique namespaces. They are easily promoted from instances to hero (you just turn their \u201cinstanceable\u201d property off).  ", {"text": ["Point Instancers"], "type": "strong"}, " are fast, but the transforms of all instances are set as array attributes on the point instancer primitive.  Promotion involves mutating the scene."]}, {"indent": 0, "type": "para", "extent": [3790, 3964], "text": ["There are LOP nodes for promoting both point instances and native instances, so point instances should be preferred mostly based on the number of instances that will exist."]}], "indent": 0, "level": 2, "text": ["Instancing"], "extent": [2604, 2621], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [3990, 4449], "text": ["A scene in USD is called a stage, and rather than simply load a file, USD composes the stage. This is because only on rare occasions is the entire scene stored in a single, flat file. Usually there are at least a few layers (each ", {"text": [".usd/.usda/.usdc"], "type": "code"}, " file on disk), and they are composed together in to present the user with a complete view of the scenegraph. The composed stage is a hierarchy of prims, representing all of the models, characters, props, etc\u2026"]}, {"body": [{"indent": 0, "type": "para", "extent": [4464, 4703], "text": ["Layers contain ", {"text": ["opinions"], "type": "em"}, " about prims in the scene graph. Some of these opinions define prims and values, while others overlay values. Layers are read from files on disk, and can also exist purely in-memory (known as \u201canonymous\u201d layers)."]}], "indent": 0, "level": 3, "text": ["Layers"], "extent": [4449, 4464], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [4721, 4952], "text": ["Sublayers are one of the most common composition arcs in USD.  Layers can have multiple SubLayers, and the list of SubLayers is ordered strongest to weakest.  The ordered list of a Layer and its SubLayers is called a LayerStack. "]}, {"indent": 0, "type": "para", "extent": [4952, 4990], "text": ["Here is an example Layer for a shot:"]}, {"lang": "usd", "indent": 0, "type": "pre", "extent": [4990, 5195], "text": ["\n#usda 1.0\n(\n    subLayers = [\n            @shotLighting.usd@,\n            @shotFX.usd@,\n            @shotAnimation.usd@,\n            @shotSetDressing.usd@,\n            @sequence.usd@\n    ]\n)\n"]}, {"indent": 0, "type": "para", "extent": [5195, 5633], "text": ["With USD, artists only need to author their contribution to the scene, as all layers will be composed together. In the above example, Animation\u2019s layer only contains the animated points and/or transforms which they have animated. A shot\u2019s layout only contains transforms, adjusting the sequence-wide set dressing defined in the sequence layer; and it may include shot-specific models or changes due to the camera or story requirements."]}, {"indent": 0, "type": "para", "extent": [5633, 6096], "text": ["One important characteristic of layers is they can be muted. When a layer is muted, the stage is recomposed and all opinions from the muted layer(s) are no longer affecting the scene. If a layer ends up breaking something in a shot, or has undesirable effect, it can be muted rather than removed from a list of sublayers. A layer does not have to be a sublayer, in order to be muted, but generally those are the ones that would end up being muted in production."]}, {"indent": 0, "type": "para", "extent": [6096, 6380], "text": ["For example, FX might have authored at the above ", {"text": ["shot.usda"], "type": "code"}, " layer, and shot playback is super slow. In this case, an artist loading the shot could just mute the ", {"text": ["shotFX.usd"], "type": "code"}, " layer, which would make USD recompose the shot, but ignore all opinions coming from the ", {"text": ["shotFX.usd"], "type": "code"}, " layer."]}], "indent": 0, "level": 3, "text": ["SubLayers"], "extent": [4703, 4721], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [6399, 6621], "text": ["A Reference is the other most common composition arc, and is generally used to compose assets and props into the scene. Unlike SubLayers, References are composed into a specified prim path (namespace) in the scenegraph. "]}, {"indent": 0, "type": "para", "extent": [6621, 6669], "text": ["For example, here is a simple trash can asset:"]}, {"lang": "usd", "indent": 0, "type": "pre", "extent": [6669, 6912], "text": ["\n#usda 1.0\n(\n   defaultPrim = \"TrashCan\"\n)\n\n\ndef Xform \"TrashCan\" (\n   kind = \"component\"\n)\n{\n   def Cylinder \"Can\"\n   {\n       token axis = \"Y\"\n       bool doubleSided = 0\n       double height = 2\n       double radius = 1\n   }\n}\n"]}, {"indent": 0, "type": "para", "extent": [6912, 7008], "text": ["Here is a layer which references the trash can asset 3 times, for 3 different rooms in a set:"]}, {"lang": "usd", "indent": 0, "type": "pre", "extent": [7008, 7771], "text": ["\n#usda 1.0\n()\n\n\ndef Xform \"Scene\"\n{\n   def Xform \"Set\"\n   {\n       def \"BathroomTrashCan\" (\n           append references = @./trashcan.usda@\n       )\n       {\n           double3 xformOp:translate = (2, 0, 1.4)\n           uniform token[] xformOpOrder = [\"xformOp:translate\"]\n       }\n\n\n       def \"KitchenTrashCan\" (\n           append references = @./trashcan.usda@\n       )\n       {\n           double3 xformOp:translate = (16.01, 5, -43.072)\n           uniform token[] xformOpOrder = [\"xformOp:translate\"]\n       }\n\n\n       def \"OfficeTrashCan\" (\n           append references = @./trashcan.usda@\n       )\n       {\n           double3 xformOp:translate = (-7.12, 0, 11.9)\n           uniform token[] xformOpOrder = [\"xformOp:translate\"]\n       }\n   }\n}\n"]}, {"indent": 0, "type": "para", "extent": [7771, 8060], "text": ["While references may give the appearance of instancing, they are not actually instanced. A prim can be declared instanceable, and USD will then optimize and share those prims among each instance. However instance-references cannot have unique overrides to prims below the instance root."]}], "indent": 0, "level": 3, "text": ["References"], "extent": [6380, 6399], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [8080, 8537], "text": ["Another powerful composition arc, VariantSets allow for building discrete variants of an asset. Asset variations to be expressed, while keeping an asset\u2019s namespace intact. Variants aren\u2019t restricted in what they can store, a VariantSet might simply swap materials, or it can change the entire hierarchy. VariantSets don\u2019t have to be defined on the asset, they can be introduced by downstream contributors. Variants cannot be time sampled (i.e. animated)."]}, {"indent": 0, "type": "para", "extent": [8537, 8699], "text": ["Here is an example of a layer which contains a variantSet called \u201cowner\u201d, where each variant\u2019s color corresponds to which character in the story owns that ball:"]}, {"lang": "usd", "indent": 0, "type": "pre", "extent": [8699, 9375], "text": ["\n#usda 1.0\n()\n\n\ndef Sphere \"toyBall\" (\n    variants = {\n        string owner = \"blake\"\n    }\n    append variantSets = \"owner\"\n)\n{\n    double radius = 1\n    variantSet \"owner\" = {\n        \"andy\" (\n        ) {\n            color3f[] primvars:displayColor = [(1, 0, 0)] (\n                interpolation = \"constant\"\n            )\n\n\n        }\n        \"blake\" (\n        ) {\n            color3f[] primvars:displayColor = [(0, 0, 1)] (\n                interpolation = \"constant\"\n            )\n\n\n        }\n        \"sally\" (\n        ) {\n            color3f[] primvars:displayColor = [(0, 1, 0)] (\n                interpolation = \"constant\"\n            )\n\n\n        }\n    }\n}\n"]}], "indent": 0, "level": 3, "text": ["VariantSets"], "extent": [8060, 8080], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [9404, 9885], "text": ["Composition in USD is a pretty deep topic, so don\u2019t be surprised when it takes a while before concepts start to sink in. You can get an awful lot of mileage out of Sublayers, References/Payloads, and VariantSets. While it\u2019s good to understand all of the composition arcs, these 3 are definitely the most frequently encountered. But to help you understand the bigger picture of composition, here is a quick summary of the arcs, from strongest to weakest (except for Specializes):"]}, {"body": [{"body": [{"indent": 0, "text": ["Layer Stack "], "role": "td", "extent": [9916, 9939], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [9939, 10212], "text": ["Layer Stack, which includes a layer\u2019s local opinions as well as sublayers. Contributions to a shot, such as the character animation or camera, would generally be sublayers. See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-SubLayers"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Inherits "], "role": "td", "extent": [10212, 10223], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [10223, 10582], "text": ["Inherits can be used to re-define the default values but only in the context of a shot or set. Inherits are similar to a local reference, but remains \u201clive\u201d through multiple levels of references. Materials are the primary use case for inherits and specializes.See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Inherits"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["VariantSets "], "role": "td", "extent": [10582, 10596], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [10596, 11084], "text": ["Pre-defined changes or variations of part of a scene or asset, without necessarily mutating important parts of a scene. For example, book asset may contain several \u201ctitle\u201d variants. This allows artists to change which title a book is, without changing the namespace of the books on a table (thus preserving things like light-linking or transforms on each instance of a book in a scene). See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-VariantSet"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["References "], "role": "td", "extent": [11084, 11097], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [11097, 11509], "text": ["Simple mechanism to reference smaller units of a scene into larger ones, such as assets into a set. Think of it as a sort of \u201cmacro\u201d to compactly reuse scene description. References would be used to assembly a shelf of books; the bookshelf and the books would references the shelf and book assets respectively. See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-References"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Payload "], "role": "td", "extent": [11509, 11519], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [11519, 11786], "text": ["Just like a reference, but can be unloaded for optimization. Most heavy parts of assets (i.e. geometry) are generally behind a payload within an asset, for this reason. See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Payload"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Specializes "], "role": "td", "extent": [11786, 11800], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [11800, 12178], "text": ["Similar to inherits, in redefining default values in a shot or set, without changing the original source. Specializes are a way to broadcast these changes, but without overriding any inhert\u2019s opinions. Materials are the primary use case for inherits and specializes. See ", {"text": ["the USD docs"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Specializes"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Name "], "role": "th", "extent": [9885, 9893], "type": "cell"}, {"indent": 8, "role": "th", "type": "cell", "extent": [9893, 9916], "text": ["Description "]}], "divider": false, "type": "row"}]}, {"indent": 0, "type": "para", "extent": [12178, 12343], "text": ["For deeper information see ", {"text": ["LIVRPS Strength Ordering in the USD Glossary"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-LIVRPSStrengthOrdering"}, "."]}], "indent": 0, "level": 3, "text": ["More on Composition"], "extent": [9375, 9404], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Composing the Stage"], "extent": [3964, 3990], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [12355, 13066], "text": ["Hydra is the mechanism with which scene description is drawn in the viewport. The plugin which Hydra talks to, in order to give you images to see, is called a delegate. And just like the monster with multiple heads, Hydra can support multiple renderers. This means that at the flip of a switch, we can look at our composed stage using any number of renderers. USD by default uses an OpenGL renderer called hdStorm (or Hydra GL in Houdini), but also includes a render delegate for RenderMan (hdPrman) and an example Embree delegate. All of these are visible by using the usdview application that ship with USD. In LOPs, or using the usdview which ships with Houdini, you\u2019ll also find the Karma render delegate."]}, {"indent": 0, "type": "para", "extent": [13066, 13381], "text": ["Obviously there is much more to USD, but hopefully these basics are enough to get started using Solaris. For further information on USD, please check out the excellent PDF slides from the USD Course at SIGGRAPH 2019. Also check out openusd.org; the glossary in particular is an excellent resource to keep at-hand."]}], "indent": 0, "level": 2, "text": ["Hydra"], "extent": [12343, 12355], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [13395, 13672], "text": ["Houdini\u2019s new layout, look development, and lighting context is LOPs, which stands for Lighting Operators. LOP Networks are similar to SOPs, however instead of using Houdini\u2019s geometry model, LOPs uses USD. This is why an understanding of both Houdini and USD is essential."]}, {"body": [{"indent": 0, "type": "para", "extent": [13690, 13948], "text": ["Most USD-authoring applications work on a session layer or on an Edit Target. In contrast, because of Houdini\u2019s procedural cooking and USD being the language/data of LOPs, everything you do in a LOP graph is editing a layer which contributes to your scene."]}, {"indent": 0, "type": "para", "extent": [13948, 14491], "text": ["When you load a layer from disk (whether by reference or sublayer) or create a primitive with a Cube or Sphere LOP, LOPs creates its own layers to contain or access the data you\u2019ve provided. The strongest implicit layer is usually the one LOP nodes are writing to, but LOPs can also write to other layers in the stack, or even add new implicit layers. Most of the time, artists don\u2019t need to worry about these implicit layers. The Output to Disk section has more information about layers in LOPs, and when an artists would likely care about."]}, {"indent": 0, "type": "para", "extent": [14491, 14814], "text": ["There is a session layer and separate stage used for the Scene Viewer, but the only edits that currently end up there are activation/visibility opinions set via the Scene Graph Tree. The viewer\u2019s stage copies the stage contents from the LOP node with the display flag, after the whole LOP graph\u2019s cook chain is completed."]}, {"indent": 0, "type": "para", "extent": [14814, 14936], "text": [{"text": ["This presentation by Scott Keating from Siggraph 2019"], "scheme": null, "type": "link", "exists": true, "value": "https://vimeo.com/351433429"}, " is an excellent overview of Solaris."]}], "indent": 0, "level": 3, "text": ["Overview"], "extent": [13672, 13690], "container": true, "type": "h", "id": null}, {"body": [], "indent": 0, "level": 3, "text": ["Target Primitive Patterns"], "attrs": {"id": "targetprimitivepatterns"}, "extent": [14936, 14970], "container": true, "type": "h", "id": null}, {"indent": 0, "type": "para", "extent": [15003, 15172], "text": ["The most direct way to target one or more prims, is to manually enter their paths. This will obviously get tedious, so there are a few easier ways to target primpaths:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [15172, 15254], "text": ["Drag & Drop - Drag path(s) from the Scene Graph Tree onto a Prim Path parameter"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [15254, 15347], "text": [{"keys": ["LMB"], "text": null, "type": "keys"}, " on Selector (white arrow on right side of parm)- Prompts to select in the viewport"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [15347, 15422], "text": [{"keys": ["Ctl"], "text": null, "type": "keys"}, " + ", {"keys": ["LMB"], "text": null, "type": "keys"}, " on Selector - Prompts to select from a primitive tree"]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [15422, 15644], "text": ["Apart from providing full primpaths, there is some useful extra syntax to make targeting primpaths easier and more expressive. Please see the ", {"fragment": "#primitivepatterns", "text": ["Tech Notes"], "value": "intro#primitivepatterns", "fullpath": "/solaris/intro#primitivepatterns", "scheme": null, "type": "link"}, " for more information on pattern matching."]}, {"indent": 0, "type": "para", "extent": [15644, 16152], "text": ["Many/most LOPs have their default set to ", {"text": ["`opinput(\".\", 0)`"], "tag": "code", "type": "xml", "attrs": {}}, " This expression is intended to be a convenience, to reduce tediously re-typing primitive paths over and over. When a LOP cooks, it can store any prim(s) it operated on and/or generated as it\u2019s last modified prims. The ", {"text": ["lopinputprims()"], "type": "code"}, " is convenience around ", {"text": ["lastmodifiedprims()"], "type": "code"}, ". This mechanism is also convenient because if the upstream paths change, the LOP nodes will likely retarget any altered prim paths automatically."]}, {"body": [{"indent": 0, "type": "para", "extent": [16180, 16275], "text": ["LOPs provides a suite of nodes for setting core properties of different parts of your scenes."]}, {"body": [{"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [16293, 16379], "text": ["Sets layer properties, such as it\u2019s save path, default prim, flattening, etc\u2026"]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Configure Layer"], "extent": [16275, 16293], "blevel": 2, "type": "bullet"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [16402, 16592], "text": ["Configure a prim\u2019s purpose, setup proxies, and add asset information. This primitive is currently more robust at pruning than the Prune LOP, so use it for activation/visibility needs."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Configure Primitives"], "extent": [16379, 16402], "blevel": 2, "type": "bullet"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [16615, 16695], "text": ["Add more specific metadata about properties and attributes on primitives."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Configure Properties"], "extent": [16592, 16615], "blevel": 2, "type": "bullet"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [16713, 16774], "text": ["Set layer muting and population masks for the scene."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Configure Stage"], "extent": [16695, 16713], "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 3, "text": ["Configuration Nodes"], "extent": [16152, 16180], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Solaris"], "extent": [13381, 13395], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [16802, 16958], "text": ["Because LOPs works with USD scene description, merging inputs has some important considerations that SOPs or other contexts don\u2019t have. Merge has 3 modes:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [16958, 17067], "text": [{"text": ["Separate Layers"], "type": "strong"}, " - merges each input\u2019s layer stack and combines them all into a new layer stack (default)"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [17067, 17164], "text": [{"text": ["Flattened Layers"], "type": "strong"}, " - flattens all of the layers in each input\u2019s layerstack down into one layer"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [17164, 17221], "text": [{"text": ["Flattened Inputs"], "type": "strong"}, " - flattens each input into a layer"]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [17221, 17349], "text": [{"text": ["Separate Layers"], "type": "em"}, " mode does not itself strip out any layers marked by a Layer Break; only the two \u2018Flattening\u2019 modes do that. "]}, {"indent": 0, "type": "para", "extent": [17349, 17407], "text": ["This table illustrates the behavior of each Merge style:"]}, {"body": [{"body": [{"indent": 0, "text": ["Separate Layers "], "role": "td", "extent": [17527, 17554], "type": "cell"}, {"indent": 4, "text": ["3 "], "role": "td", "extent": [17554, 17562], "type": "cell"}, {"indent": 8, "text": ["3 "], "role": "td", "extent": [17562, 17574], "type": "cell"}, {"body": [{"indent": 16, "type": "para", "extent": [17574, 17593], "text": ["9 "]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Flattened Layers "], "role": "td", "extent": [17593, 17612], "type": "cell"}, {"indent": 5, "text": ["3 "], "role": "td", "extent": [17612, 17621], "type": "cell"}, {"indent": 8, "text": ["3 "], "role": "td", "extent": [17621, 17633], "type": "cell"}, {"body": [{"indent": 16, "type": "para", "extent": [17633, 17652], "text": ["1 "]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Flattened Inputs "], "role": "td", "extent": [17652, 17671], "type": "cell"}, {"indent": 5, "text": ["3 "], "role": "td", "extent": [17671, 17680], "type": "cell"}, {"indent": 8, "text": ["3 "], "role": "td", "extent": [17680, 17692], "type": "cell"}, {"body": [{"indent": 16, "type": "para", "extent": [17692, 17712], "text": ["3"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Merge Style "], "role": "th", "extent": [17407, 17422], "type": "cell"}, {"indent": 8, "text": ["Num Inputs "], "role": "th", "extent": [17422, 17444], "type": "cell"}, {"indent": 16, "text": ["Layers per Input "], "role": "th", "extent": [17444, 17480], "type": "cell"}, {"indent": 24, "role": "th", "type": "cell", "extent": [17480, 17527], "text": ["Resulting Sublayers "]}], "divider": false, "type": "row"}]}, {"indent": 0, "type": "para", "extent": [17712, 17963], "text": ["It is important to remember, that Merge is a LayerStack, a list of Sublayers. This means the input order matters, with the first input weakest and the last input strongest. This ordering can be seen in the Layer Stack tab of the Scene Graph Details."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [17982, 18030], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_1.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_1.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"body": [{"indent": 0, "type": "para", "extent": [18054, 18459], "text": ["Context Options are special variables that can be used to alter the context of a LOP network. For example, one could use these to switch a graph between several different shots or for wedging different lighting setups. Context options can be global, or special blocks can be setup in the network, to locally set context options. ForEach LOPs can be thought of as a specialized flavor of context options."]}, {"indent": 0, "type": "para", "extent": [18459, 18603], "text": ["There is also a ", {"text": ["Contexts Options Editor"], "type": "em"}, " found under ", {"text": ["Edit \u25b8 Context Options"], "type": "ui"}, " which provides a rich interface for defining context options."]}], "indent": 0, "level": 3, "text": ["Context Options"], "extent": [18030, 18054], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Merging"], "attrs": {"id": "ordermatters"}, "extent": [16774, 16788], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [18633, 18688], "text": ["Please see ", {"text": ["Using USD with VEX"], "fullpath": "/solaris/vex", "scheme": null, "type": "link", "value": "vex"}, " for more info.  "]}, {"indent": 0, "type": "para", "extent": [18688, 19121], "text": ["VEX is Houdini\u2019s programming language used for everything from deformers to shaders to solvers. As VEX is a SIMD language, its code/network snippets are designed to run on each \u2018element\u2019 being targeted. In LOPs this means primitives by default, meaning there is no need to add a loop to iterate over each target primitive; that happens automatically. Each attribute of the primitives is accessed using the ", {"text": ["@"], "type": "code"}, " syntax, or Bind VOPs."]}, {"indent": 0, "type": "para", "extent": [19121, 19422], "text": ["Wrangle and VOP LOP also have a second mode, ", {"text": ["Run on Elements of Array Attributes"], "type": "em"}, ". In this case, the elements over which the code will run are the elements of array properties on primitives. This allows for faster operations over PointInstancer or Points prims, or even the points of heavy meshes. "]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [19422, 19470], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_2.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_2.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 2, "text": ["VEX, Wrangles, and VOPs"], "extent": [18603, 18633], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [19488, 19669], "text": ["USD Collections can be thought of as groups for primitives, and LOPs has a few mechanisms to make working with collections convenient.  Collection specifiers can take three forms:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [19669, 19709], "text": [{"text": ["/foo/bar.collection:collection_name"], "type": "code"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [19709, 19739], "text": [{"text": ["%/foo/bar/collection_name"], "type": "code"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [19739, 19761], "text": [{"text": ["%collection_name"], "type": "code"}]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [19761, 19986], "text": ["Other collections can be an Include Pattern; however Exclude Patterns cannot target another collection yet; only explicit paths can be excluded. Most parameters looking for prim path(s) can also take a collection specifier."]}], "indent": 0, "level": 2, "text": ["Collections"], "extent": [19470, 19488], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [20006, 20589], "text": ["A very interesting utility LOP, the ", {"text": ["Stage Manager LOP"], "fullpath": "/nodes/lop/stagemanager", "scheme": "Node", "type": "link", "value": "/nodes/lop/stagemanager"}, " is designed to be a one-stop location for referencing assets from disk, transforming them in 3d space, and adjusting your scene hierarchy. It has a custom Qt interface and Python State, to take care of the UX part, but the node itself is capable of creating, moving, copying, and deleting primitives. Mostly these only work on prims which have been defined in the same layer/lop network which the stage manager is functioning, since USD doesn\u2019t allow a layer to re-define existing prim paths/namespaces."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [20589, 20637], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_3.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_3.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 2, "text": ["Stage Manager"], "extent": [19986, 20006], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [20649, 20850], "text": ["Graft is a different animal. It uses some low-level USD functions to do something USD normally doesn\u2019t do well, it combines different input stages together, at arbitrary locations in the scene graph."]}, {"indent": 0, "type": "para", "extent": [20850, 20907], "text": ["Here is a more detailed explanation from the developer:"]}, {"indent": 0, "type": "para", "extent": [20907, 21663], "text": [{"text": ["The first input is passed through unchanged. The second and following inputs each have their layers flattened to a single layer (one layer per input). Then the root primitive of each of those flattened layers is copied (using SdfCopySpec) to a location on the stage. Each input can be sent to a completely different location. The path that serves as the root for each input is calculated by taking the Primitive Path parameter, and appending the per-input string specified in the Inputs widget at the bottom of the parameter dialog. If a given input doesn\u2019t have a value specified, it instead appends the \u201cDestination Path Default\u201d parameter to the Primitive Path parameter (where the Destination Path Default gets evaluated separately for each input)."], "type": "em"}]}, {"indent": 0, "type": "para", "extent": [21663, 22105], "text": [{"text": ["The fact that ", {"text": ["SdfCopySpec"], "type": "code"}, " is used to bring the inputs' contents onto the stage, and that the layers of each input are flattened can make this a pretty expensive operation. But it effectively allows you to combine a bunch of separate stages together with each stage being put at an arbitrary location in the final scene graph tree. This manipulation of the scene graph hierarchy is not something that USD generally makes very easy to do."], "type": "em"}]}], "indent": 0, "level": 2, "text": ["Graft"], "extent": [20637, 20649], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [22126, 22554], "text": ["USD Layers can be written to disk using a ", {"text": ["ROP USD Output LOP"], "fullpath": "/nodes/lop/rop_usd", "scheme": "Node", "type": "link", "value": "/nodes/lop/rop_usd"}, ". This can be a simple operation, that writes out a flattened stage to a single USD layer on disk. Because USD composition arcs can be intricate, USD exports have support for elaborate multi-file exports. This section is not exhaustive, as the topic can get quite complex, but should provide enough context to understand what the USD ROP is doing."]}, {"body": [{"indent": 0, "type": "para", "extent": [22571, 22986], "text": ["The ", {"text": ["ROP USD Output LOP"], "fullpath": "/nodes/lop/rop_usd", "scheme": "Node", "type": "link", "value": "/nodes/lop/rop_usd"}, " is the primary engine which writes out USD layers to disk. It has options for writing out per-frame files, which directory to store sublayers, and omitting start/end timecode metadata. It also supports render-time Context Options. The key parameter though is the Save Style. This determines how the LOP graph and the scene description it generates, is expressed on disk."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [22986, 23178], "text": ["Flatten Implicit Layers - Flattens layers implied by Configure Layer LOPs or \u201cSave Path\u201d parameters. Also has options to flatten any SOP layers and/or File layers. References are preserved."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [23178, 23298], "text": ["Flatten All Layers - Flattens all sublayers into the Output File, ignoring implicit layers. References are preserved."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [23298, 23560], "text": ["Flatten Stage - Every bit of composed scene description on the stage is flattened into the Output File. Useful for debugging or portability, but not generally used. Can produce extremely large files and take a very long time, on large scale production scenes!"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [23560, 23708], "text": ["Separate Layers -  Every layer on the Layer Stack is saved to disk, and is a Sublayer in the Output File. Preserves all sublayers and references"]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [23708, 23955], "text": ["When writing out multiple layers at once, layers with the .usd extension will use the same layer extension as found on the ROP\u2019s Output File. If you want to force a Save Path layer to be ascii or binary, you must use .usda or .usdc respectively."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [23955, 24003], "text": [{"text": [".usd"], "type": "code"}, " - binary, or use output file extension"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [24003, 24021], "text": [{"text": [".usda"], "type": "code"}, " - ascii"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [24021, 24041], "text": [{"text": [".usdc"], "type": "code"}, " - binary"]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 3, "text": ["USD ROP"], "extent": [22554, 22571], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [24065, 24350], "text": ["Implicit layers are layers created in memory by the LOP Network which may be flattened into other explicit layers (also created by the LOP Network), and thus disappear as independent entities during the save process (though any opinions they express are preserved by the flattening)."]}], "indent": 0, "level": 3, "text": ["Implicit Layers"], "extent": [24041, 24065], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Output to Disk"], "extent": [22105, 22126], "container": true, "type": "h", "id": null}, {"body": [], "indent": 0, "level": 2, "text": ["Layer Break"], "attrs": {"id": "layerbreak"}, "extent": [24350, 24368], "container": true, "type": "h", "id": null}, {"indent": 0, "type": "para", "extent": [24392, 24943], "text": ["The ", {"text": ["Layer Break LOP"], "fullpath": "/nodes/lop/layerbreak", "scheme": "Node", "type": "link", "value": "/nodes/lop/layerbreak"}, " blocks upstream scene description from being written into a layer, at the time a USD ROP writes the layer to disk. Any changes to the scene graph by downstream LOPs, that affect scene description above the Layer Break, will be authored as Overlays. Layer Break allows artists to be more surgical when authoring USD layers. Layer Breaks only take effect when some operation flattens layers on the stage; examples include a ROP writes out to disk, and Merge / Configure Layers set to some style of flattening."]}, {"indent": 0, "type": "para", "extent": [24943, 25331], "text": ["In the example below, the only scene description below the Layer Break is a wrangle adding a displayColor. When the layer is written out to disk, the Layer Break strips out the layer and keeps it sparse. This is valuable for an artist to author specific overrides to their department\u2019s layer, without accidentally re-authoring sublayers or other parts of the scene graph unnecessarily. "]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [25331, 25379], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_4.jpg", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_4.jpg"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"body": [{"indent": 0, "type": "para", "extent": [25396, 25812], "text": ["SOP Layers can be brought into a scene either as References or as Sublayers (SOP layer names end in \u201c.sop\u201d, which can be seen in the Layer Stack or Composition tabs of the Scene Graph Details pane). By default, a SOP layer\u2019s node path will be its path on disk (relative to the Output File or Sublayer Directory). The USD Configure SOP can be used to override the layer\u2019s output path to a specific location on disk."]}], "indent": 0, "level": 2, "text": ["SOP Layers"], "extent": [25379, 25396], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "type": "para", "extent": [25845, 26440], "text": ["The ", {"text": ["LOP Import SOP"], "fullpath": "/nodes/sop/lopimport", "scheme": "Node", "type": "link", "value": "/nodes/sop/lopimport"}, " brings part or all of a scene into SOPs. Based on the primitive pattern and purpose, you can import USD primitives as USD Packed Prims into SOPs. By default it ignores layer breaks. Also the Time at which the prims are imported is the scene\u2019s start frame by default; if you need to bring in animated geometry, you can to set Time to $FF. However, this will be slow and does a lot of work unnecessarily, most of the time. You can get much faster results by animating the usdFrame intrinsic via Wrangle or VOP, found on the USD Packed Prims in your scene."]}, {"indent": 0, "type": "para", "extent": [26440, 26494], "text": [{"text": ["setprimintrinsic(0, \u201cusdFrame\u201d, @primnum, @Frame);"], "type": "code"}]}], "indent": 0, "level": 3, "text": ["LOP Import"], "extent": [25826, 25845], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [26513, 27083], "text": ["For bringing SOP data back into LOPs, use the ", {"text": ["SOP Import SOP"], "fullpath": "/nodes/lop/sopimport", "scheme": "Node", "type": "link", "value": "/nodes/lop/sopimport"}, ". There is a ", {"text": ["USD Configure SOP"], "fullpath": "/nodes/sop/usdconfigure", "scheme": "Node", "type": "link", "value": "/nodes/sop/usdconfigure"}, " which has all the same options, for setting up output layers and options in SOP-land, which is used when ", {"text": ["Load as Reference"], "type": "em"}, " is turned on.  Be aware, USD defaults to right-hand oriented meshes, whereas Houdini\u2019s is left-handed.  If your meshes are right-handed, remember to turn on \u2018Reverse Polygon Vertex Ordering\u2019 when modifying geometry in SOPs. You\u2019ll also want to make sure the mesh prims are properly set to be Subdivs or not."]}, {"indent": 0, "type": "para", "extent": [27083, 27193], "text": ["There are some point attributes, which can be used to create new primitives in USD, based on points in SOPs:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [27193, 27236], "text": [{"text": ["s@usdprimtype"], "type": "code"}, " - sets the usd prim type"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [27236, 27263], "text": [{"text": ["s@path"], "type": "code"}, " - the prim path"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [27263, 27290], "text": [{"text": ["s@name"], "type": "code"}, " - the prim name"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [27290, 27319], "text": [{"text": ["s@usdkind"], "type": "code"}, " - set the kind"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [27319, 27407], "text": ["Standard houdini transform attributes can set the transform of the prim (P, N, etc\u2026)"]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [27407, 27954], "text": ["When converting SOP geometry back to LOPs, try to be as efficient as possible. By default, attributes will be time sampled, but you can designate attributes to not be time sampled by adding them to \u2018Set Default Values\u2019. Remember to also set the ", {"text": ["Topology Attributes"], "type": "em"}, " to ", {"text": ["Static"], "type": "em"}, " as well, to get non-time sampled attributes. USD (and specifically Hydra) do more work when values are time sampled, even if there is only a single time sample. In small setups it probably won\u2019t make much difference, but larger scenes will definitely have an impact."]}, {"indent": 0, "type": "para", "extent": [27954, 28046], "text": ["Here is the conversion between Houdini Geometry attributes and USD primvars interpolation:"]}, {"body": [{"body": [{"indent": 0, "text": ["Detail "], "role": "td", "extent": [28068, 28082], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28082, 28095], "text": ["Constant"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Primitive "], "role": "td", "extent": [28095, 28107], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28107, 28119], "text": ["Uniform"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Vertex "], "role": "td", "extent": [28119, 28128], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28128, 28144], "text": ["faceVarying"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Point "], "role": "td", "extent": [28144, 28152], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28152, 28172], "text": ["Vertex"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Houdini "], "role": "th", "extent": [28046, 28057], "type": "cell"}, {"indent": 4, "role": "th", "type": "cell", "extent": [28057, 28068], "text": ["USD "]}], "divider": false, "type": "row"}]}, {"indent": 0, "type": "para", "extent": [28172, 28259], "text": ["These standard Houdini attributes convert to the equivalent USD standard by default:"]}, {"body": [{"body": [{"indent": 0, "text": ["Cd "], "role": "td", "extent": [28281, 28286], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28286, 28312], "text": ["primvars:displayColor"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Alpha "], "role": "td", "extent": [28312, 28320], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28320, 28348], "text": ["primvars:displayOpacity"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["widths, width, pscale "], "role": "td", "extent": [28348, 28372], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28372, 28383], "text": ["widths"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["P "], "role": "td", "extent": [28383, 28387], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28387, 28398], "text": ["points"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["N "], "role": "td", "extent": [28398, 28402], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28402, 28414], "text": ["normals"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["bounds "], "role": "td", "extent": [28414, 28423], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28423, 28435], "text": ["extents"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["v "], "role": "td", "extent": [28435, 28439], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28439, 28454], "text": ["velocities"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["id "], "role": "td", "extent": [28454, 28459], "type": "cell"}, {"body": [{"indent": 4, "type": "para", "extent": [28459, 28476], "text": ["ids"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Houdini "], "role": "th", "extent": [28259, 28270], "type": "cell"}, {"indent": 4, "role": "th", "type": "cell", "extent": [28270, 28281], "text": ["USD "]}], "divider": false, "type": "row"}]}, {"indent": 0, "type": "para", "extent": [28476, 28578], "text": ["Note that for the widths attribute, preference is given to ", {"text": ["@widths"], "type": "code"}, ", then ", {"text": ["@width"], "type": "code"}, ", then ", {"text": ["@pscale"], "type": "code"}, "."]}, {"indent": 0, "type": "para", "extent": [28578, 29068], "text": ["Something to be aware of, when importing geometry back from SOPs. After your mesh/points prim(s) are unpacked via USD Unpack SOP, a point attribute called \u2018usdxform\u2019 is added. This represents the computed world transform of the UsdPrim that point came from. Because the unpacked points are in their computed world space position, we can use ", {"text": ["@usdxform"], "type": "code"}, " to return the points back into UsdPrim-space. This can be done using a Transform by Attribute, and toggling on \u2018Invert Transformation\u2019."]}], "indent": 0, "level": 3, "text": ["SOP Import"], "extent": [26494, 26513], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [29094, 29386], "text": ["An HDA wrapper around a SOP network and LOP/SOP Imports, to quickly modify and/or create geometry. The SOP Modify is a general-case/best-practice example of taking prims through a LOP-SOP-LOP cycle. It provides built-in support for transforming points back into UsdPrim-space automatically."]}], "indent": 0, "level": 3, "text": ["SOP Modify/Create"], "extent": [29068, 29094], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["SOP I/O"], "extent": [25812, 25826], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [29409, 29744], "text": ["The Point Instancer schema is designed to draw vast amounts of geometry as fast as possible. It was designed and implemented primarily for FX artists, who are often required to simulate and animate lots of debris. The Point Instancer LOP uses Houdini\u2019s standard instance attributes on points to adjust the transform of each instance."]}, {"indent": 0, "type": "para", "extent": [29744, 30131], "text": ["Each model instanced across the points is called a prototype, and Point Instancer prims can assign any number of prototypes. If the per-instance variations cannot be expressed via the Point Instancer primitive\u2019s attributes, then different prototypes may have to be used.  Prototypes can contain animated geometry, and Point Instancer prims can be prototypes for other Point Instancers."]}, {"indent": 0, "type": "para", "extent": [30131, 30541], "text": ["The downside is Point Instancers are less flexible for the pipeline to work around. Parenting to individual Point Instancer instances requires extra work, and any changes to individual instances is limited to the attributes available from the schema. Also, although one can use any number of unique prototypes, too many prototypes can offset the performance advantages that come from using Point Instancers."]}, {"indent": 0, "type": "para", "extent": [30541, 30639], "text": ["LOPs now provides a few LOPs for conveniently working with Point Instancers and Native Instances:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [30639, 30713], "text": ["Modify Point Instances - transform individual instances, modify w/ SOPs"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [30713, 30765], "text": ["Extract Instances - extract and promote instances"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [30765, 30828], "text": ["Material Variation - authors primvars for shading variation"]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Point Instancers"], "extent": [29386, 29409], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "type": "para", "extent": [30869, 31262], "text": ["The network editor for LOPs is quite similar to SOPs in Houdini. Nodes which don\u2019t contribute to the current display are styled differently. By default the descriptive parms are often the targeted prim path(s), and there is another label showing the number of layers being displayed.These can be turned off via the Network Editor\u2019s Display Options (", {"text": ["View \u25b8 Display Options \u25b8 Text Badges"], "type": "ui"}, ")."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [31262, 31310], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_5.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_5.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 0, "type": "para", "extent": [31310, 31782], "text": ["LOP nodes have a ", {"text": ["Debug Flag"], "type": "em"}, ", and its function is related to how LOP networks are cooked. Normally each LOP makes a copy of the strongest layer in the stack, does its work on that working copy, then copies its contents back to the strongest layer on the stack. When a node has the debug flag enabled, instead of copying back to the strongest, it adds its working layer to the top of the stack. This makes the LayerStack grow with each node, instead of staying constant."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [31782, 31830], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_6.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_6.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 0, "type": "para", "extent": [31830, 32120], "text": ["The Network Editor also puts a colored outline around LOP nodes which are editing the same layer. The color itself is random, and does not indicate anything apart from their editable layers being the same. This can be disabled in the Network Editor, under ", {"text": ["View \u25b8 Show LOP Layer Colors"], "type": "ui"}]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [32120, 32168], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_7.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_7.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 3, "text": ["Network Editor"], "extent": [30845, 30869], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [32187, 32537], "text": ["By default, LOPs has its own HoudiniGL delegate which allows for selecting prims and using handles to edit your scene. The selection tools allow for using kind to select elements of the scene. Different Renderers can be selected from the drop-down (currently only Houdini GL and Hydra GL are practical), and one can look through cameras and lights."]}, {"indent": 0, "type": "para", "extent": [32537, 32749], "text": ["Currently, if your current node is a Camera LOP, you can (more or less) lock the view to the Camera and navigate, as is possible outside of LOPs. However, controlling lights this way is still a bit troublesome."]}, {"indent": 0, "type": "para", "extent": [32749, 32914], "text": ["To customize the context menu of the Scene Graph Tree, you can create UsdStagePrimMenu.xml on $HOUDINI_PATH; this same menu is also used with the Scene Graph Tree."]}], "indent": 0, "level": 3, "text": ["Scene View"], "extent": [32168, 32187], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [32939, 32988], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_8.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_8.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 0, "type": "para", "extent": [32988, 33508], "text": ["Displays the composed USD stage in the top section, and Collections in the bottom section. Visibility/Active and Draw Mode opinions expressed here are stored in the session layer, but won\u2019t get written out to disk. A few operations will actually create a new node in the graph, such as changing a variant. The Scene Graph Tree is also able to load and unload payloads. It also has various options for filtering prims/collections, and displaying different prim metadata. There is also a section for showing Collections."]}, {"indent": 0, "type": "para", "extent": [33508, 33701], "text": ["The stage shown comes from the node selection, not necessarily the node w/ the display flag by default. However, there is a preference (Edit > Preferences > Lighting) to change this behavior."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [33701, 33749], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_9.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_9.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 0, "type": "para", "extent": [33749, 33843], "text": ["The text of primitives will change color/style to indicate more information about the scene:"]}, {"body": [{"body": [{"indent": 0, "text": ["Reference, Specialize, Inherit "], "role": "td", "extent": [33970, 34003], "type": "cell"}, {"indent": 4, "text": ["Payload, Reference w/ Payload "], "role": "td", "extent": [34003, 34039], "type": "cell"}, {"indent": 8, "text": ["Unloaded Payload "], "role": "td", "extent": [34039, 34066], "type": "cell"}, {"indent": 12, "text": ["Instance "], "role": "td", "extent": [34066, 34089], "type": "cell"}, {"indent": 16, "text": ["Master Prims (instance children) "], "role": "td", "extent": [34089, 34140], "type": "cell"}, {"body": [{"indent": 20, "type": "para", "extent": [34140, 34180], "text": ["Viewport override "]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Green "], "role": "th", "extent": [33843, 33852], "type": "cell"}, {"indent": 4, "text": ["Orange "], "role": "th", "extent": [33852, 33866], "type": "cell"}, {"indent": 8, "text": ["Dark Orange "], "role": "th", "extent": [33866, 33889], "type": "cell"}, {"indent": 12, "text": ["Blue "], "role": "th", "extent": [33889, 33910], "type": "cell"}, {"indent": 16, "text": ["Dark Blue "], "role": "th", "extent": [33910, 33939], "type": "cell"}, {"indent": 20, "role": "th", "type": "cell", "extent": [33939, 33970], "text": ["Red Dot "]}], "divider": false, "type": "row"}]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [34180, 34238], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_10.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_10.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 0, "type": "para", "extent": [34238, 34370], "text": ["To customize the context menu of the Scene Graph Tree, you can edit/create the same ", {"text": ["UsdStagePrimMenu.xml"], "type": "code"}, " used by the Scene View."]}], "indent": 0, "level": 3, "text": ["Scene Graph Tree"], "extent": [32914, 32939], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [34398, 34786], "text": ["Shows the properties of the selected primitive, as well as any metadata, and the layers contributing opinions to the selected prim. The Composition tab will show all composition arcs contributing to the selected  prim/attribute, which are known as PrimStacks and PropertyStacks, respectively. PrimStacks/PropertyStacks are a bit different from LayerStacks, though similar in principle. "]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [34786, 34835], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_11.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_11.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 3, "text": ["Scene Graph Details"], "extent": [34370, 34398], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [34868, 35119], "text": ["Allows for inspecting the layers used in the scene. It also has some mechanisms for muting layers, but this particular muting only affects the viewport, it doesn\u2019t persist in the scene graph the same way that muting a layer via Configure Stage does."]}], "indent": 0, "level": 3, "text": ["Scene Graph Layers Panel"], "extent": [34835, 34868], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [35143, 35667], "text": ["An extremely powerful LOP, the ", {"text": ["Edit Properties LOP"], "fullpath": "/nodes/lop/editproperties", "scheme": "Node", "type": "link", "value": "/nodes/lop/editproperties"}, " used to create and edit USD primitives. Its interface is defined from the ", {"text": ["Edit Properties"], "type": "em"}, " button on its UI, allowing you to pick and apply properties based on specific primitive schemas or just USD property types in general. ", {"text": ["Edit Properties"], "type": "em"}, " can also be directly turned into a digital asset; several native nodes such as Light, Camera, and all of the \u201cprimitive\u201d LOPs (i.e. Cube, Cone, etc\u2026), are actually HDAs generated by ", {"text": ["Edit Properties"], "type": "em"}, "."]}], "indent": 0, "level": 3, "text": ["Edit Properties"], "extent": [35119, 35143], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [35687, 35795], "text": ["There are a few preferences provided for LOPs, which can be found under ", {"text": ["Edit \u25b8 Preferences \u25b8 Lighting"], "type": "ui"}, "."]}, {"body": [{"indent": 0, "role": "item", "type": "fig", "extent": [35795, 35850], "text": [{"text": "", "fullpath": "/images/solaris/tutorial/js_12.png", "scheme": "Image", "type": "link", "value": "/images/solaris/tutorial/js_12.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 3, "text": ["Preferences"], "extent": [35667, 35687], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Interfaces"], "extent": [30828, 30845], "container": true, "type": "h", "id": null}], "type": "root", "attrs": {"index": "no"}, "title": ["Solaris Jumpstart"]}