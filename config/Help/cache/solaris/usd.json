{"body": [{"indent": 0, "text": ["USD Basics"], "type": "title", "extent": [0, 15], "level": 0}, {"indent": 0, "type": "summary", "extent": [15, 107], "text": ["Introduces a number of USD concepts, and how they relate to Houdini\u2019s USD support."]}, {"body": [{"indent": 0, "type": "para", "extent": [122, 434], "text": ["USD is a system of software and file formats for describing 3D scenes by ", {"text": ["composing layers"], "type": "em"}, ". For example, a master USD file describing a kitchen scene (", {"text": ["kitchen.usd"], "type": "code"}, ")might reference layer files containing props (", {"text": ["chair.usd"], "type": "code"}, ", ", {"text": ["table.usd"], "type": "code"}, "), lighting, characters, and so on, composing them into a single ", {"text": ["stage"], "type": "em"}, "."]}, {"indent": 0, "type": "para", "extent": [434, 969], "text": ["The main power of the layer paradigm is ", {"text": ["non-destructive editing"], "type": "em"}, ". You can start with an existing scene and create a new layer containing your edits. These edits won\u2019t affect other people using the same scene unless they choose to include your new layer. You can also replace one of the layers (for example a newer version of an asset or updated lighting) and automatically re-apply all existing changes on top of it. This allows multiple departments to collaborate, share data, and update assets without interfering with each other."]}, {"indent": 0, "type": "para", "extent": [969, 1345], "text": ["Houdini\u2019s tooling and support for USD is collectively known as Solaris. Solaris includes USD support in the view and a new network type, LOPs (Light Operators).  LOP networks are slightly similar to SOPs, where each node accepts incoming geometry, modifies it, and outputs new geometry. In LOPs, each node accepts an incoming USD scene, modifies it, and outputs a new scene."]}, {"indent": 0, "type": "para", "extent": [1345, 1721], "text": ["Because USD is a very comprehensive framework, it is not simple. LOPs is designed so you don\u2019t ", {"text": ["need"], "type": "em"}, " to know about the underlying USD structure. However, wherever possible LOP parameters use USD terminology, and are sometimes a thin wrapper around functionality built into USD. A basic understanding of USD concepts and features will make it much easier to understand LOPs."]}, {"indent": 0, "type": "para", "extent": [1721, 1840], "text": ["The following page explains the basics of USD, and relates them to how Solaris supports working with USD in Houdini."]}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [107, 122], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [1860, 2149], "text": ["Normally ", {"text": [".usd"], "type": "code"}, " (or ", {"text": [".usdc"], "type": "code"}, ") files are binary encoded for efficiency, however the USD scene description format has an plain text equivalent (", {"text": [".usda"], "type": "code"}, ") that is human-readable. Here is a very simple ", {"text": [".usda"], "type": "code"}, " example to introduce some USD ", {"fragment": "#concepts", "text": ["concepts"], "value": "#concepts", "fullpath": "/solaris/usd#concepts", "scheme": null, "type": "link"}, " we\u2019ll explain in this document:"]}, {"body": [{"body": [{"lang": "usd", "indent": 4, "type": "pre", "extent": [2165, 2258], "text": ["\n    #usda 1.0\n    def Cube \"box\" {\n        double size = 4.0\n    }\n    "]}], "indent": 0, "text": [{"text": ["box.usda"], "type": "code"}], "role": "item", "extent": [2149, 2165], "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"indent": 0, "type": "para", "extent": [2258, 2892], "text": ["In this example, ", {"text": ["def"], "type": "code"}, " is a keyword defining a new prim (USD also has an ", {"text": ["over"], "type": "code"}, " operator that is like ", {"text": ["def"], "type": "code"}, " but defines how a new prim ", {"text": ["overrides"], "type": "em"}, " an existing prim). ", {"text": ["Cube"], "type": "code"}, " is the prim\u2019s ", {"text": ["type"], "type": "em"}, ". What \"being a ", {"text": ["Cube"], "type": "code"}, "\" means and what properties a ", {"text": ["Cube"], "type": "code"}, " has are defined by a ", {"text": ["schema"], "type": "em"}, ". ", {"text": ["box"], "type": "code"}, " is the name of the primitive (this prim will appear in the scene tree as ", {"text": ["/box"], "type": "code"}, "). The ", {"text": ["Cube"], "type": "code"}, " prim type is defined by the built-in USD Geometry schema. There are additional built-in schema for volumes, shading, lighting, skeletal animation, and rendering. You can ", {"fragment": "#extend", "text": ["extend USD"], "value": "#extend", "fullpath": "/solaris/usd#extend", "scheme": null, "type": "link"}, " by creating a custom schema to define your own prim types."]}, {"indent": 0, "type": "para", "extent": [2892, 3101], "text": ["The code inside curly braces ", {"text": ["{ }"], "type": "code"}, " defines the new prim\u2019s ", {"text": ["child primitives"], "type": "em"}, " and ", {"text": ["properties"], "type": "em"}, " (the ", {"text": ["Cube"], "type": "code"}, " has many properties but those we don\u2019t specify will be filled in with defaults from the type schema)."]}, {"indent": 0, "type": "para", "extent": [3101, 3420], "text": ["In USD jargon, this is bit of code may be said to \"author an opinion about the size of /box\". When ", {"fragment": "#compose", "text": ["composing layers"], "value": "#compose", "fullpath": "/solaris/usd#compose", "scheme": null, "type": "link"}, ", if a layer contains an \"opinion\" about the value of a property, it will be ", {"text": ["overridden"], "type": "em"}, " if a layer with a ", {"fragment": "#strength", "text": ["stronger opinion"], "value": "#strength", "fullpath": "/solaris/usd#strength", "scheme": null, "type": "link"}, " has a different opinion (value) for the same property."]}, {"indent": 0, "type": "para", "extent": [3420, 3457], "text": ["Now consider a second ", {"text": [".usda"], "type": "code"}, " file:"]}, {"body": [{"body": [{"lang": "usd", "indent": 4, "type": "pre", "extent": [3479, 3647], "text": ["\n    #usda 1.0\n    def \"box1\" ( references = @box.usda@ ) {\n\n    }\n    def \"box2\" ( references = @box.usda@ ) {\n        float size = 2.0\n    }\n    "]}], "indent": 0, "text": [{"text": ["two_boxes.usda"], "type": "code"}], "role": "item", "extent": [3457, 3479], "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"indent": 0, "type": "para", "extent": [3647, 3870], "text": ["In this file, we import the contents of the ", {"text": ["box.usda"], "type": "code"}, " file above twice as two prims: ", {"text": ["/box1"], "type": "code"}, " and ", {"text": ["/box2"], "type": "code"}, ". ", {"text": ["/box1"], "type": "code"}, " will inherit its ", {"text": ["size"], "type": "code"}, " attribute from the referenced layer. ", {"text": ["/box2"], "type": "code"}, " ", {"text": ["overrides"], "type": "em"}, " ", {"text": ["size"], "type": "code"}, " with a new value."]}, {"indent": 0, "type": "para", "extent": [3870, 4262], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, you generally won\u2019t directly manipulate the values of attributes on primitives (although there are nodes for doing low-level edits). Instead, LOP nodes specify higher-level operations (such as \"bring in this geometry\", \"point this light at this object\", \"place this prop on this table with physics\") and the LOPs author the corresponding USD automatically."]}, {"indent": 0, "type": "para", "extent": [4262, 4499], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " You can actually inject plain text USD code into the stage built by a LOP network using the ", {"text": ["Inline USD LOP"], "fullpath": "/nodes/lop/inlineusd", "scheme": "Node", "type": "link", "value": "/nodes/lop/inlineusd"}, ". This can sometimes be useful for debugging, but is not how you should work normally!"]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [4504, 4841], "text": ["A file with the extension ", {"text": [".usd"], "type": "code"}, " may be ", {"text": ["either"], "type": "em"}, " the binary format or the plain text format. This to make it easy to switch a file from one representation to another without messing up asset tracking or version control. A file with the extension ", {"text": [".usda"], "type": "code"}, " should always be the plain text format, and ", {"text": [".usdc"], "type": "code"}, " should always be binary."]}], "indent": 0, "role": "item", "type": "tip", "extent": [4499, 4504]}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 2, "text": ["Quick example"], "extent": [1840, 1860], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [4888, 5112], "text": ["Primitives are the basic \"unit\" of USD. \"Primitive\" is often shortened to \"prim\" when talking about USD. Similar to an \"element\" in HTML, prims have a name, zero or more named ", {"text": ["properties"], "type": "em"}, ", and zero or more ", {"text": ["children"], "type": "em"}, "."]}, {"indent": 4, "type": "para", "extent": [5112, 5268], "text": ["For example, a polygonal mesh is a prim, a light is a prim, a material is a prim. An \"xform\" prim stores a transform that applies to it\u2019s child prims."]}, {"indent": 4, "type": "para", "extent": [5268, 5341], "text": ["Prims are the \"nodes\" in the tree of objects that define a ", {"text": ["stage"], "type": "em"}, "."]}], "indent": 0, "type": "dt", "extent": [4867, 4888], "text": ["Primitives (prims)"]}, {"body": [{"indent": 4, "type": "para", "extent": [5380, 5470], "text": ["\"Property\" is the generic name for two types of named data you can attach to a prim:"]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [5486, 5691], "text": [{"fragment": "#attrs", "text": ["Attributes"], "value": "#attrs", "fullpath": "/solaris/usd#attrs", "scheme": null, "type": "link"}, " are typed values (such as integers, colors, transform matrices, arrays, and so on) that describe the prim (for example, ", {"text": ["float size = 1.0"], "type": "code"}, " defines a Cube prim\u2019s uniform size)."]}, {"indent": 8, "type": "para", "extent": [5691, 5749], "text": ["This is by far the most common form of property."]}], "indent": 4, "type": "dt", "extent": [5470, 5486], "text": ["Attributes"]}, {"body": [{"indent": 8, "type": "para", "extent": [5768, 5956], "text": ["Relationshsips establish a link between one prim and another (for example, specifying the material to use when shading a mesh prim, or specifying the primitives in a collection)."]}], "indent": 4, "type": "dt", "extent": [5749, 5768], "text": ["Relationships"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "extent": [5341, 5380], "text": ["Properties, attributes, relationships"]}, {"body": [{"indent": 4, "type": "para", "extent": [5966, 6251], "text": ["Properties themselves can have named values attached to them, which can modify how they work. For example, if specify a point color ", {"fragment": "#primvars", "text": ["primvar"], "value": "#primvars", "fullpath": "/solaris/usd#primvars", "scheme": null, "type": "link"}, " for a mesh, you can add ", {"text": ["interpolation"], "type": "code"}, " metadata that specifies how the renderer should blend between the colors on the points."]}, {"indent": 4, "type": "para", "extent": [6251, 6479], "text": ["Metadata is also used to attach \"extra\" data that may be specific to a particular DCC, or may be useful for debugging or building a user interface. For example, documentation for different attributes is stored in metadata."]}], "indent": 0, "type": "dt", "extent": [5956, 5966], "text": ["Metadata"]}, {"body": [{"indent": 4, "type": "para", "extent": [6487, 6946], "text": ["A single ", {"text": [".usd"], "type": "code"}, " file is a layer (a ", {"text": [".usdz"], "type": "code"}, " file, on the other hand, can contain multiple layers in a single archive file). A layer can represent a \"piece\" of a scene such as a prop, a character, part of a rig, a lighting setup, and so on. It can also represent \"defaults\" that you can reference in to create a baseline, for example a layer containing settings for a shot sequence, which you reference in the files representing each shot in the sequence."]}, {"indent": 4, "type": "para", "extent": [6946, 7023], "text": ["See ", {"fragment": "#organize", "text": ["how to organize layers and stages"], "value": "#organize", "fullpath": "/solaris/usd#organize", "scheme": null, "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "extent": [7023, 7483], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, various nodes create new in-memory layers to override existing data. You can also create a new layer \"manually\" with the ", {"text": ["Layer Break LOP"], "fullpath": "/nodes/lop/layerbreak", "scheme": "Node", "type": "link", "value": "/nodes/lop/layerbreak"}, ". A typical LOP network will involve many layers, some imported from disk and some created in-memory by nodes, that are composed together by the end. (An optional visualization in the network editor shows you which nodes in the network work on different layers.)"]}], "indent": 0, "type": "dt", "extent": [6479, 6487], "text": ["Layers"]}, {"body": [{"indent": 4, "type": "para", "extent": [7501, 7740], "text": ["References from one layer to another. For example, a scene layer might bring in layers containing props, lighting, and so on. Those layers might reference their own sub-layers, those sub-layers may bring in sub-sub-layers, and so on."]}, {"indent": 4, "type": "para", "extent": [7740, 7872], "text": ["Layers are ", {"fragment": "#compose", "text": ["composited"], "value": "#compose", "fullpath": "/solaris/usd#compose", "scheme": null, "type": "link"}, " together, merging the prims in each layer. Properties in higher layers ", {"text": ["override"], "type": "em"}, " the values "]}, {"indent": 4, "type": "para", "extent": [7872, 8240], "text": ["For example, a scene file may reference a lighting layer, but the lighting department may have composed that layer itself from three sub-layers representing \"base defaults\", \"finished lighting\", and \"in-progress lighting\". Other departments don\u2019t need to know that\u2019s how the lighting layer is composed, they just need to reference the top-level \"lighting\" layer."]}, {"indent": 4, "type": "para", "extent": [8240, 8542], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " You can use the ", {"text": ["Reference LOP"], "fullpath": "/nodes/lop/reference", "scheme": "Node", "type": "link", "value": "/nodes/lop/reference"}, " to add references to layer you are building in-memory using nodes in the LOP network. You can use the ", {"text": ["Sublayer LOP"], "fullpath": "/nodes/lop/sublayer", "scheme": "Node", "type": "link", "value": "/nodes/lop/sublayer"}, " to load an existing sub-layer (a ", {"text": [".usd"], "type": "code"}, " file) into the layer stack of the current stage."]}], "indent": 0, "type": "dt", "extent": [7483, 7501], "text": ["Composition arcs"]}, {"body": [{"indent": 4, "type": "para", "extent": [8549, 8716], "text": ["When you load a USD file and the system ", {"fragment": "#compose", "text": ["composes"], "value": "#compose", "fullpath": "/solaris/usd#compose", "scheme": null, "type": "link"}, " all the layers together to compute the final scene graph of prims, that result is called the ", {"text": ["stage"], "type": "em"}, "."]}, {"indent": 4, "type": "para", "extent": [8716, 9002], "text": ["Note that ", {"text": ["stage"], "type": "em"}, " is just a name for the ", {"text": ["result"], "type": "em"}, ". There is no difference between a \"stage file\" and a \"layer file\"\u2026 if you load a ", {"text": [".usd"], "type": "code"}, " file as a \"top-level\" file, it creates a stage. In another circumstance, you might reference that same file as a layer in a different stage."]}, {"indent": 4, "type": "para", "extent": [9002, 9439], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, the LOP node at the top of the network creates a stage, and each subsequent LOP modifies the contents of that stage procedurally, creating a new stage. So for any LOP node you can use ", {"fragment": "#stage", "text": "", "value": "/hom/hou/LopNode#stage", "fallback_text": "hou.LopNode.stage", "fullpath": "/hom/hou/LopNode#stage", "scheme": "Hom", "type": "link"}, " to get the stage object output by that node. You can view the stage output by a node as ", {"text": ["usda"], "type": "code"}, " syntax by right-clicking the LOP node and choosing ", {"text": ["LOP Actions \u25b8 Inspect Flattened Stage"], "type": "ui"}, "."]}], "indent": 0, "type": "dt", "extent": [8542, 8549], "text": ["Stage"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Concepts"], "extent": [4841, 4867], "container": true, "type": "h", "id": "concepts"}, {"body": [{"indent": 0, "type": "para", "extent": [9477, 9737], "text": ["In USD, attributes are often scalar values that contain a prim\u2019s \"settings\". For example, on a ", {"text": ["Sphere"], "type": "code"}, " prim, the ", {"text": ["radius"], "type": "code"}, " attribute controls the size of the sphere. In this sense, attributes are similar to node parameters in Houdini, or attributes in Maya."]}, {"indent": 0, "type": "para", "extent": [9737, 10060], "text": ["In USD, geometry settings, such as per-point variables, are ", {"text": ["also"], "type": "em"}, " stored as attributes on the prim. They are stored as ", {"text": ["arrays"], "type": "em"}, ", with one element for each component. For example, the ", {"text": ["points"], "type": "code"}, " attribute on a mesh prim stores the point positions in an array of coordinates. This is the same as Houdini geometry attributes."]}, {"indent": 0, "type": "para", "extent": [10060, 10208], "text": ["USD also recognizes a specific type of attribute called a ", {"text": ["primvar"], "type": "em"}, ". (The name primvar comes from Renderman, and stands for \"primitive variable\".)"]}, {"indent": 0, "type": "para", "extent": [10208, 10685], "text": ["At the basic tree level, primvars are just attributes with the ", {"text": ["primvars:"], "type": "code"}, " schema namespace prefix. What makes them special is how Hydra treats them during rendering. Their main purpose is to override material parameters. However they have useful behaviors that mean they're also used to represent per-object properties that may affect geometry rendering aside from materials. Karma, for example, lets you use primvars to specify the number of motion blur frames per-object."]}, {"body": [{"indent": 0, "type": "para", "extent": [10715, 11061], "text": ["A primvar is even more like a Houdini geometry attribute, which can also override material parameters in traditional Houdini rendering, than plain USD attributes. Like Houdini\u2019s geometry attributes, if there is no primvar data available for a certain part of a curve/surface, the system will interpolate between the nearest available primvars."]}, {"body": [{"indent": 1, "type": "para", "extent": [11487, 11643], "text": [{"text": ["Vertex"], "type": "strong"}, " interpolation is (confusingly) equivalent to a Houdini point attribute. The interpolation method is stored as metadata on the primvar attribute."]}], "indent": 0, "type": "para", "extent": [11061, 11487], "text": [{"text": ["How"], "type": "em"}, " the system interpolates primvars essentially defines the \"level\" of the primvar, like how Houdini has vertex attributes, point attributes, primitive attributes, and global (detail) attributes. In USD, ", {"text": ["Constant"], "type": "strong"}, " interpolation is equivalent to a Houdini detail attribute. ", {"text": ["Uniform"], "type": "strong"}, " interpolation is equivalent to a Houdini primitive attribute. ", {"text": ["FaceVarying"], "type": "strong"}, " interpolation is equivalent to a Houdini vertex attribute. And"]}, {"indent": 0, "type": "para", "extent": [11643, 12026], "text": ["The number of values in the primvar\u2019s array should correspond to the number of components corresponding to the chosen interpolation method. For example, a Uniform (per-face) primvar on a cube should have 6 values, but a Vertex (per-point) primvar on a cube should have 8 values. It is up to the renderer to apply the primvar values to override the material parameters as specified."]}, {"indent": 0, "type": "para", "extent": [12026, 12450], "text": ["Interpolation between available values is the main feature of primvars. This is why on a Mesh primitive, the ", {"text": ["points"], "type": "code"}, " attribute is a plain attribute, but ", {"text": ["primvars:displayColor"], "type": "code"}, " is a primvar. Point positions cannot be \"interpolated\". The length of that array defines the number of points in the mesh. But the display color could be constant across the entire primitive, or have a value for each polygon, point, or vertex."]}], "indent": 0, "level": 3, "text": ["Primvar interpolation"], "extent": [10685, 10715], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [12478, 12614], "text": ["The other feature that separates primvars from plain attributes is that \"Constant\" primvars are ", {"text": ["inherited down the scene graph tree"], "type": "em"}]}, {"indent": 0, "type": "para", "extent": [12614, 12794], "text": ["For example, if a prim ", {"text": ["/Geometry/props"], "type": "code"}, " has a ", {"text": ["constant"], "type": "strong"}, " value for ", {"text": ["primvars:displayColor"], "type": "code"}, ", all descendants of ", {"text": ["/Geometry/props"], "type": "code"}, " will use that same color unless it\u2019s overridden."]}, {"indent": 0, "type": "para", "extent": [12794, 13006], "text": ["This inheritance is why primvars are used for per-object render settings. You can set a value on a high-level primitive (for example decreasing the dicing quality), and have it affect large parts of the scene."]}], "indent": 0, "level": 3, "text": ["Primvar Inheritance"], "extent": [12450, 12478], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [13038, 13293], "text": ["When a point instancer has a \"Vertex\" (per-point) array primvar, for each instance it looks up the corresponding value in the array, and treats that as a \"Constant\" primvar on the instance. This is how per-point-instance material overrides work in USD."]}, {"indent": 0, "type": "para", "extent": [13293, 13635], "text": ["Similarly, you can set a \"Constant\" primvar on an ", {"fragment": "#instancing", "text": ["instanceable prim"], "value": "#instancing", "fullpath": "/solaris/usd#instancing", "scheme": null, "type": "link"}, ", that primvar will be inherited and affect the material parameters of primitives inside the instance (which can otherwise not be edited). This is the only way data from outside an instanceable prim can affect the appearance of primitives under the instance."]}], "indent": 0, "level": 3, "text": ["Primvars and instancing"], "extent": [13006, 13038], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Attributes and primvars"], "extent": [9439, 9477], "container": true, "type": "h", "id": "attrs"}, {"body": [{"indent": 0, "type": "para", "extent": [13663, 13776], "text": ["Every USD file contains a complete \"scene\". USD files can import the contents of other USD files as ", {"text": ["layers"], "type": "em"}, ". "]}, {"indent": 0, "type": "para", "extent": [13776, 13983], "text": ["The USD libraries include software for composing/overlaying multiple layers into the full scene (stage) created by the top-level file. Composition includes merging the following differences between layers:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [13983, 13997], "text": ["New prims."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [13997, 14015], "text": ["Prim ordering."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14015, 14066], "text": ["Whether a prim is ", {"fragment": "#active", "text": ["active or inactive"], "value": "#active", "fullpath": "/solaris/usd#active", "scheme": null, "type": "link"}, "."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14066, 14108], "text": [{"fragment": "#variants and variant sets", "text": ["Variants"], "value": "#variants and variant sets", "fullpath": "/solaris/usd#variants and variant sets", "scheme": null, "type": "link"}, "."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14108, 14158], "text": ["New properties (attributes and relationships)."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14158, 14278], "text": ["Attribute values. (Higher layers can even \"block\" (unset) the value of an attribute so it appears to be unassigned)."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14278, 14298], "text": ["Metadata values."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [14298, 14506], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Houdini automatically composes the various on-disk and in-memory layers created as you edit USD. You can also use tools to understand what\u2019s on each layer and how layers are composed."]}, {"body": [{"indent": 0, "type": "para", "extent": [14548, 14806], "text": ["USD has two different approaches to \"importing\" the contents of another USD file: ", {"text": ["sub-layering"], "type": "em"}, " overlays the tree of the imported file over the current tree, while ", {"text": ["referencing"], "type": "em"}, " attaches the contents of the imported tree as a branch on the existing tree."]}, {"indent": 0, "type": "para", "extent": [14806, 15151], "text": ["You can think of sublayering as ", {"text": ["composing different versions of the whole scene"], "type": "em"}, " (for example, overlaying the lighting department\u2019s version of the scene with final lighting over the layout department\u2019s version of the scene with scratch lighting), and referencing as ", {"text": ["adding a part to the scene"], "type": "em"}, " (for example, importing props to begin layout)."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [15187, 15453], "text": ["Sublayering overlays the contents of the imported file over the existing contents. Each tree\u2019s \"opinions\" about prims with the same path, and (on those prims) properties/metadata with the same name, are merged based on ", {"fragment": "#strength", "text": ["opinion strength"], "value": "#strength", "fullpath": "/solaris/usd#strength", "scheme": null, "type": "link"}, " (see below)."]}, {"indent": 4, "type": "para", "extent": [15453, 15662], "text": ["This is useful when combining files that are each meant to contribute a portion of a complete scene. For example, composing separate layers representing set layout, props, characters, effects,and lights."]}, {"indent": 4, "type": "para", "extent": [15662, 15823], "text": ["An inherent feature of sublayering is that \"everything stays in the same place\". Prims have the same path in the new file as they had in their source file."]}, {"indent": 4, "type": "para", "extent": [15823, 16134], "text": ["Because each of these departments is working in a separate sublayer, they don\u2019t need to worry about sharing a single file and having conflicting edits. But because they are all working in the same scene graph hierarchy, each department can apply changes to any of the content created by other departments."]}, {"indent": 4, "type": "para", "extent": [16134, 16489], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " The ", {"text": ["Sublayer LOP"], "fullpath": "/nodes/lop/sublayer", "scheme": "Node", "type": "link", "value": "/nodes/lop/sublayer"}, " loads new sublayers into the scene. LOP networks in general are always editing the strongest sublayer of an empty root layer. Some LOP nodes may start a new, stronger sublayer which is then modified by all following LOP nodes. These network output is the composition of this sublayer stack."]}], "indent": 0, "text": ["Sub-layering"], "attrs": {"id": "sublayering"}, "extent": [15151, 15165], "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [16524, 16630], "text": ["Referencing takes the tree in the referenced file and \"grafts\" it onto a branch in the current tree."]}, {"indent": 4, "type": "para", "extent": [16630, 16677], "text": ["For example, if you start with this tred:"]}, {"body": [{"body": [{"text": [{"text": ["\nLights\n    light1\n    light2\nModels\n    tableside_lamp\n        "], "tag": "font", "type": "xml", "attrs": {"color": "0066ff"}}], "tag": "pre", "type": "xml", "attrs": {}}], "indent": 4, "text": ["Scene tree before reference"], "role": "item", "extent": [16677, 16715], "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"indent": 4, "type": "para", "extent": [16828, 16907], "text": ["If ", {"text": ["/Models/tableside_lamp"], "type": "code"}, " references ", {"text": ["lamp.usd"], "type": "code"}, " and that file contains:"]}, {"body": [{"body": [{"text": [{"text": ["\nlamp\n    base\n    bulb\n    shade\n    socket\n    switch\n        "], "tag": "font", "type": "xml", "attrs": {"color": "#ff9900"}}], "tag": "pre", "type": "xml", "attrs": {}}], "indent": 4, "text": ["Contents of ", {"text": ["lamp.usd"], "type": "code"}], "role": "item", "extent": [16907, 16940], "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"indent": 4, "type": "para", "extent": [17054, 17120], "text": ["Then after referncing the file, the tree will look like this"]}, {"body": [{"body": [{"text": [{"text": ["\nLights\n    light1\n    light2\nModels\n    ", {"text": ["tableside_lamp"], "tag": "font", "type": "xml", "attrs": {"color": "#66cc00"}}, "\n        ", {"text": ["base\n        bulb\n        shade\n        socket\n        switch"], "tag": "font", "type": "xml", "attrs": {"color": "#ff9900"}}, "\n        "], "tag": "font", "type": "xml", "attrs": {"color": "0066ff"}}], "tag": "pre", "type": "xml", "attrs": {}}], "indent": 4, "text": ["Scene tree after reference"], "role": "item", "extent": [17120, 17157], "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [17398, 17664], "text": ["The prim containing the reference (", {"text": ["/Models/tableside_lamp"], "type": "code"}, ") and the referenced prim (", {"text": ["/lamp"], "type": "code"}, " from ", {"text": ["lamp.usd"], "type": "code"}, ") are composed together (with overlapping property values decided by opinion strength), but the prim keeps the name of the original referencing prim."]}, {"body": [{"indent": 8, "type": "para", "extent": [17967, 18163], "text": ["(It\u2019s possible to specify the ", {"fragment": "#default_prim", "text": ["default primitive"], "value": "#default_prim", "fullpath": "/solaris/usd#default_prim", "scheme": null, "type": "link"}, " of a file. If you reference a file and don\u2019t specify a specific prim in the file, you get the file\u2019s \"default primitive\".)"]}], "indent": 4, "text": ["When you reference in content, you must specify a prim in the referenced file (", {"text": ["/lamp"], "type": "code"}, " in the example above), and that prim cannot be the root (", {"text": ["/"], "type": "code"}, "). So when you're creating a file that is meant to be referenced in by other layers, you should organize the contents under a single root primitive."], "extent": [17664, 17967], "blevel": 6, "type": "bullet"}], "container": true, "type": "bullet_group"}, {"indent": 4, "type": "para", "extent": [18163, 18469], "text": ["Referencing is useful to graft smaller individual assets into a larger scene. In particular, ", {"text": ["referencing is the only way to load the same layer file more than once at different locations"], "type": "strong"}, ". (Because sublayering works on the entire tree, sublayering the same file more than once would have no effect.)"]}], "indent": 0, "text": ["Referencing"], "attrs": {"id": "referencing"}, "extent": [16489, 16502], "type": "dt"}], "container": true, "type": "dt_group"}, {"indent": 0, "type": "para", "extent": [18469, 18760], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " The ", {"text": ["Reference LOP"], "fullpath": "/nodes/lop/reference", "scheme": "Node", "type": "link", "value": "/nodes/lop/reference"}, " and ", {"text": ["Stage Manager LOP"], "fullpath": "/nodes/lop/stagemanager", "scheme": "Node", "type": "link", "value": "/nodes/lop/stagemanager"}, " create references. The ", {"text": ["Graft LOP"], "fullpath": "/nodes/lop/graft", "scheme": "Node", "type": "link", "value": "/nodes/lop/graft"}, " is similar, but instead of referencing from a file, it inserts a branch into the scene graph tree from elsewhere in the LOP network."]}, {"indent": 0, "type": "para", "extent": [18760, 19198], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Keeping track of how multiple levels of sublayering and referencning work together to generate the final opinion on a primitive at a single scene graph location can become complicated. You can use the ", {"text": ["Layer Stack"], "type": "ui"}, " and ", {"text": ["Composition"], "type": "ui"}, " tabs of the ", {"text": ["Scene Graph Details pane"], "fullpath": "/ref/panes/scenegraphdetails", "scheme": null, "type": "link", "value": "/ref/panes/scenegraphdetails"}, " can examine which layers contribute to the primitive, and how those different layers were composed together."]}], "indent": 0, "level": 3, "text": ["Sublayers, references"], "extent": [14506, 14548], "container": true, "type": "h", "id": "sublayers"}, {"body": [{"indent": 0, "type": "para", "extent": [19226, 19518], "text": ["A payload is essentially a reference, but it\u2019s possible to have USD not load payloads until they are specifically requested. This lets you control which parts of a scene are loaded into memory, keeping memory use and processing time down by focusing on the parts of a scene you care about."]}, {"indent": 0, "type": "para", "extent": [19518, 19681], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, you specify whether a referenced file is a plain reference or a payload in the parameters of the node that references the file."]}, {"indent": 0, "type": "para", "extent": [19681, 19977], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " By default Houdini loads all payloads (and so they behave exactly like references). But the Configure Stage LOP and the Load Masks controls in the scene graph tree allow you to disable default loading of payloads, and then choose which specific payloads you want to load."]}], "indent": 0, "level": 3, "text": ["Payloads"], "extent": [19198, 19226], "container": true, "type": "h", "id": "payloads"}, {"body": [{"indent": 0, "type": "para", "extent": [20020, 20223], "text": ["Because it is designed for non-destructive editing, USD does not allow ", {"text": ["deleting"], "type": "em"}, " primitives. However, you can ", {"text": ["override"], "type": "em"}, " primitives with new values, or ", {"text": ["deactivate"], "type": "em"}, " primitives so they have no effect."]}, {"indent": 0, "type": "para", "extent": [20223, 20473], "text": ["You can also edit the ", {"text": ["visibility"], "type": "em"}, " of objects in the scene. By default, USD prims are visible. The visibility option only has two settings: \"inherit\" and \"invisible\". So marking a prim \"invisible\" always makes all its descendants invisible as well."]}, {"indent": 0, "type": "para", "extent": [20473, 20782], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Icon", "type": "link", "value": "MISC/logo"}, " In Houdini you can interactively toggle a primitive between active and inactive, and visible/invisible in the Scene Graph Tree pane to allow you to see the effects of the primitive. Houdini performs these edits in an in-memory, ", {"text": ["unsaved"], "type": "strong"}, " layer so they don\u2019t affect the final generated USD."]}], "indent": 0, "level": 3, "text": ["Activation and visibility"], "extent": [19977, 20020], "container": true, "type": "h", "id": "active"}, {"body": [{"indent": 0, "type": "para", "extent": [20818, 21196], "text": ["Attributes resolve according to \"strongest wins\" rules, so all values for any given attribute will be fetched from the strongest PrimSpec.  For example, a \"weak layer\" with a default value will be masked by a stronger layer with animation. For example, the layout department places a prop in the scene, and later the animation department adds a layer that animates that prop."]}, {"indent": 0, "type": "para", "extent": [21196, 21281], "text": ["The most common way you decide opinion strength is the ordering of the layer stack."]}, {"indent": 0, "type": "para", "extent": [21281, 21768], "text": ["For example, the weakest layer could be the layout layer, where assets are combined and positioned. The next layer may add characters to the scene from the animation department (which may move or otherwise adjust the layout if necessary by applying stronger opinions to some of those existing primitives). Then the FX department may want to add new geometry to the scene graph, or apply an RBD simulation to some of the existing primitives added by the layout or animation departments."]}, {"indent": 0, "type": "para", "extent": [21768, 21939], "text": ["The ordering of opinions follows the mneumonic LIVRPS (\"liver peas\"). These are the ways, ", {"text": ["from weakest to strongest"], "type": "strong"}, ", one layer can override another during composition:"]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [21962, 22096], "text": ["A layer that has its own opinion for a property overrides any opinions for the same property in any sub-layers it references in."]}], "indent": 0, "type": "dt", "extent": [21939, 21962], "text": ["Layer stack (weakest)"]}, {"body": [{"indent": 4, "type": "para", "extent": [22109, 22394], "text": ["\"Inherits\" can be used to re-define default values of a prim, but only in the context of a layer. Inherits are similar to a local reference, but remains \"live\" through multiple levels of references. Materials are the primary use case for \"inherits\" and \"specializes\" (see below)."]}, {"indent": 4, "type": "para", "extent": [22394, 22527], "text": ["Further reading: ", {"text": ["inherits"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Inherits"}, " in Pixar\u2019s USD glossary."]}], "indent": 0, "type": "dt", "extent": [22096, 22109], "text": ["Inheritance"]}, {"body": [{"indent": 4, "type": "para", "extent": [22537, 22655], "text": ["See ", {"fragment": "#variants", "text": ["variants"], "value": "#variants", "fullpath": "/solaris/usd#variants", "scheme": null, "type": "link"}, " below. The current variant overrides attributes on the prim containing the variant set."]}], "indent": 0, "type": "dt", "extent": [22527, 22537], "text": ["Variants"]}, {"body": [{"indent": 4, "type": "para", "extent": [22667, 22855], "text": ["\"Imports\" smaller units into a scene. For example, a dressed set file might reference a bookshelf prop file, and the bookshelf file might reference several different book prop files."]}, {"indent": 4, "type": "para", "extent": [22855, 22992], "text": ["Further reading: ", {"text": ["references"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-References"}, " in Pixar\u2019s USD glossary."]}], "indent": 0, "type": "dt", "extent": [22655, 22667], "text": ["References"]}, {"body": [{"indent": 4, "type": "para", "extent": [23002, 23236], "text": ["Just like a reference, but can be optionally unloaded to speed up viewing/rendering the scene, and reloaded later. Heavy parts of assets (such as high-res polygonal mesh skins) are referenced as payloads so they can be unloaded."]}, {"indent": 4, "type": "para", "extent": [23236, 23304], "text": ["When a payload is loaded, it overrides the \"unloaded\" version."]}, {"indent": 4, "type": "para", "extent": [23304, 23435], "text": ["Further reading: ", {"text": ["payload"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Payload"}, " in Pixar\u2019s USD glossary."]}], "indent": 0, "type": "dt", "extent": [22992, 23002], "text": ["Payloads"]}, {"body": [{"indent": 4, "type": "para", "extent": [23460, 23750], "text": ["Similar to inherits (see above), redefines default values of a prim in a layer, without changing the original source. Specializes are a way to broadcast these changes, but without overriding any \"inherits\" opinions. Materials are the primary use case for \"inherits\" and \"specializes\"."]}, {"indent": 4, "type": "para", "extent": [23750, 23889], "text": ["Further reading: ", {"text": ["specializes"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Specializes"}, " in Pixar\u2019s USD glossary."]}], "indent": 0, "type": "dt", "extent": [23435, 23460], "text": ["Specializes (strongest)"]}], "container": true, "type": "dt_group"}, {"indent": 0, "type": "para", "extent": [23889, 24033], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Icon", "type": "link", "value": "MISC/logo"}, " In Houdini, you are ", {"text": ["always authoring in the strongest opinion"], "type": "strong"}, ", so you don\u2019t usually have to think about override strengths."]}, {"indent": 0, "type": "para", "extent": [24033, 24184], "text": ["Further reading: ", {"text": ["LIVRPS ordering"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-LIVRPSStrengthOrdering"}, " in Pixar\u2019s USD glossary."]}], "indent": 0, "level": 3, "text": ["Opinion strength"], "extent": [20782, 20818], "container": true, "type": "h", "id": "strength"}, {"body": [{"indent": 0, "type": "para", "extent": [24225, 24444], "text": ["As part of its metadata, each layer can specify a \"default primitive\". This is the primitive that is referenced in if you reference in a file but don\u2019t explicitly specify what root-level prim from the file to attach."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [24444, 24594], "text": ["You can specify the default primitive (along with other layer-level metadata) for a layer using the ", {"text": ["Configure Layer LOP"], "fullpath": "/nodes/lop/configurelayer", "scheme": "Node", "type": "link", "value": "/nodes/lop/configurelayer"}, "."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [24594, 24734], "text": ["When you write out USD files, the ", {"text": ["USD render node"], "fullpath": "/nodes/out/usd", "scheme": "Node", "type": "link", "value": "/nodes/out/usd"}, " has a parameter to set the default prim for the \"top-level\" layer file."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [24734, 24942], "text": ["The ", {"text": ["USD render node"], "fullpath": "/nodes/out/usd", "scheme": "Node", "type": "link", "value": "/nodes/out/usd"}, " has an option (", {"text": ["Error Saving Layer With No Default Primitive"], "type": "ui"}, ") to cause an error if you haven\u2019t specified a default primitive for all of the layers being written out."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 3, "text": ["Default primitive"], "extent": [24184, 24225], "container": true, "type": "h", "id": "default_prim"}], "indent": 0, "level": 2, "text": ["Composition"], "extent": [13635, 13663], "container": true, "type": "h", "id": "compose"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [24980, 25157], "text": ["You can write ", {"text": ["usda"], "type": "code"}, " format code and evaluate it and insert the resulting prims directly into the in-memory scene graph tree using the ", {"text": ["Inline USD node"], "fullpath": "/nodes/lop/inlineusd", "scheme": "Node", "type": "link", "value": "/nodes/lop/inlineusd"}, "."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [25157, 25290], "text": ["You can use the Pytbon ", {"text": ["Usd"], "type": "code"}, " API to manipulate the in-memory stage directly using the ", {"text": ["Python Script LOP"], "fullpath": "/nodes/lop/pythonscript", "scheme": "Node", "type": "link", "value": "/nodes/lop/pythonscript"}, "."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Low-level USD access in Houdini"], "extent": [24942, 24980], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [25341, 25442], "text": ["The open source libraries for USD provide for plugins to load data from different file formats."]}, {"indent": 4, "type": "para", "extent": [25442, 25787], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini you will generally use a LOP node to import data such as geometry directly into USD from another network or from disk, without using USD\u2019s file import code. Houdini also includes USD plugins for Houdini file formats so you can use them in a pipeline outside Houdini (these plugins consume a batch license)."]}], "indent": 0, "type": "dt", "extent": [25319, 25341], "text": ["File format plugins"]}, {"body": [{"indent": 4, "type": "para", "extent": [25804, 26069], "text": ["In addition to explicit file paths, USD lets you encode file references using opaque ", {"text": ["asset IDs"], "type": "em"}, " (in ", {"text": ["usda"], "type": "code"}, " format, these look like ", {"text": ["@my_asset_name@"], "type": "code"}, "). A plug-in called an ", {"text": ["asset resolver"], "type": "em"}, " is then responsible for converting an asset ID into a loadable object."]}, {"indent": 4, "type": "para", "extent": [26069, 26322], "text": ["For example, if a studio stores their assets in a central Git server, they might store file references as asset IDs that contain path and revision information that is meaningful in relation to that server (for example, ", {"text": ["@/models/tintoy#bf452ac@"], "type": "code"}, ")."]}, {"indent": 4, "type": "para", "extent": [26322, 26500], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " For USD generated in Houdini, ", {"fragment": "#processors", "text": ["output processors"], "value": "output#processors", "fullpath": "/solaris/output#processors", "scheme": null, "type": "link"}, " provide for some customization, but only for file locations and file path strings."]}], "indent": 0, "type": "dt", "extent": [25787, 25804], "text": ["Asset resolvers"]}, {"body": [{"indent": 4, "type": "para", "extent": [26516, 26635], "text": ["See ", {"fragment": "#schemas", "text": ["schemas"], "value": "#schemas", "fullpath": "/solaris/usd#schemas", "scheme": null, "type": "link"}, " below. Schemas add custom types, attributes, and/or APIs to USD and define their behavior."]}], "indent": 0, "type": "dt", "extent": [26500, 26516], "text": ["Custom schemas"]}, {"body": [{"indent": 4, "type": "para", "extent": [26652, 26881], "text": ["See ", {"fragment": "#hydra", "text": ["Hydra and rendering"], "value": "#hydra", "fullpath": "/solaris/usd#hydra", "scheme": null, "type": "link"}, " below. Software uses an API (called Hydra) to direct a ", {"text": ["render delegate"], "type": "em"}, " to render USD. As long as a render delegate exists for a renderer, any software can render USD through that renderer."]}], "indent": 0, "type": "dt", "extent": [26635, 26652], "text": ["Render delegate"]}, {"body": [{"indent": 4, "type": "para", "extent": [26897, 27144], "text": ["Just as a program directs rendering through a render delegate, when a renderer needs information from the scene, it uses an API to request it from a ", {"text": ["scene delegate"], "type": "em"}, ". This can provide a level of indirection to alter the scene at render time."]}], "indent": 0, "type": "dt", "extent": [26881, 26897], "text": ["Scene delegate"]}, {"body": [{"indent": 4, "type": "para", "extent": [27159, 27279], "text": ["Each type of USD primitive is translated into a Hydra-compatible renderable representation by a prim adapter type."]}], "indent": 0, "type": "dt", "extent": [27144, 27159], "text": ["Prim adapters"]}], "container": true, "type": "dt_group"}, {"indent": 0, "type": "para", "extent": [27279, 27399], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " You can use your custom file format plugins and asset resolvers with Houdini in one of two ways:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [27399, 27542], "text": ["Build your plugins using the USD headers and libraries shipped with Houdini. (These headers and libraries are included as part of the HDK.)"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [27542, 27962], "text": ["Replace Houdini\u2019s version of the USD library with your own version. To do this you must download the ", {"text": ["HoudiniUsdBridge"], "type": "code"}, " repository from the SideFX GitHub. This repository contains all the Houdini source code that calls into USD. Rebuild that code using your own USD library, and use the results to replace the equivalent libraries in the Houdini install (either by copying them in or manipulating ", {"text": ["LD_LIBRARY_PATH"], "type": "code"}, ")."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [27962, 28209], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Solaris ", {"fragment": "#processors", "text": ["output processors"], "value": "output#processors", "fullpath": "/solaris/output#processors", "scheme": null, "type": "link"}, " provide a place to customize how files are saved (such as taking paths that are relative to ", {"text": ["$HIP"], "type": "code"}, " and making them relative to the root USD file, and tweaking file extensions)."]}], "indent": 0, "level": 2, "text": ["Extensibility"], "extent": [25290, 25319], "container": true, "type": "h", "id": "extend"}, {"body": [{"indent": 0, "type": "para", "extent": [28242, 28542], "text": ["USD refers to prims that represent geometry as ", {"text": ["gprims"], "type": "em"}, " (these are prims that, when rendered, will actually cause something to be drawn in the image, as opposed to, say, a transform prim). The schema for these prim types (", {"text": ["UsdGeomGprim"], "type": "code"}, ") contains convenient methods such as finding bounding boxes."]}, {"indent": 0, "type": "para", "extent": [28542, 28745], "text": ["USD includes a set of prims representing mathematically defined shapes (capsule, cone, cube, cylinder) as well as more complex prims that hold geometry such as polygonal meshes or subdivision surfaces."]}, {"indent": 0, "type": "para", "extent": [28745, 29012], "text": [{"text": ["Do not put gprims under other grims"], "type": "strong"}, " in the scene graph tree. Many key features of USD apply hierarchically, such as activation, visibility, and purpose, and it can be frustrating and counter-productive to be unable to apply these operations to individual gprims."]}, {"body": [{"indent": 0, "type": "para", "extent": [29034, 29152], "text": ["Kinds are one of the harder-to-understand concepts in USD. Every prim that has geometry under should have a \"kind\"."]}, {"indent": 0, "type": "para", "extent": [29152, 29293], "text": ["\"Model kinds\" are sub-classes of an \"abstract\" kind called ", {"text": ["model"], "type": "code"}, ". You should never assign ", {"text": ["model"], "type": "code"}, " as a kind. There are three model kinds:"]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [29327, 29419], "text": ["\"An important group model, often a published asset or reference to a pusblished asset\""]}], "indent": 0, "type": "dt", "extent": [29293, 29327], "text": [{"text": ["assembly"], "type": "code"}, " (subclass of ", {"text": ["group"], "type": "code"}, ")"]}, {"body": [{"indent": 4, "type": "para", "extent": [29428, 29534], "text": ["A group of other models (components, assemblies, or groups). The \"branch\" item of a model hierarchy."]}], "indent": 0, "type": "dt", "extent": [29419, 29428], "text": [{"text": ["group"], "type": "code"}]}, {"body": [{"indent": 4, "type": "para", "extent": [29547, 29682], "text": ["The \"leaf\" items of a model hierarchy, prims of this kind cannot contain other models (groups or assemblies or other components)."]}, {"indent": 4, "type": "para", "extent": [29682, 29798], "text": ["Instead, components can contain prims with kind set to ", {"text": ["subcomponent"], "type": "code"}, ". This kind is not a subclass of ", {"text": ["model"], "type": "code"}, "."]}], "indent": 0, "type": "dt", "extent": [29534, 29547], "text": [{"text": ["component"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 0, "type": "para", "extent": [29798, 30319], "text": ["Kinds support organizing the geometry in the scene into a ", {"text": ["model hierarchy"], "type": "em"}, ". This is a \"table of contents\" of the models in the scene. Maintaining this hierarchy properly allows software packages to present better UI, such as for selection, and allows more efficient traversal of the models in the scene. (For example, if software wants to show the user all the models in the scene, it only needs to start searching the tree in roots that have a kind, and can stop descending in the tree when it hits a component kind.)"]}, {"indent": 0, "type": "para", "extent": [30319, 30393], "text": ["A model hierarchy in the scene graph tree might look like the following:"]}, {"lang": null, "indent": 0, "type": "pre", "extent": [30393, 30732], "text": ["\n/Models \u2190 group\n    /Characters \u2190 group\n        /Lady \u2190 assembly\n            /Skin \u2190 component\n                /mesh\n            /Purse \u2190 component\n                /mesh\n        /Dog \u2190 assembly\n            /Skin \u2190 component\n                /mesh\n            /Collar \u2190 component\n                /mesh\n    /Props \u2190 group\n        ...\n"]}, {"indent": 0, "type": "para", "extent": [30732, 30805], "text": ["To maintain the model hierarchy, your scene should have the following:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [30805, 30951], "text": ["All prims that deal with geometry under (descending from) them should have a kind, starting, including the root prim (for example, ", {"text": ["/Models"], "type": "code"}, ")."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [30951, 31117], "text": ["Only group/assembly kinds should contain other model kinds. Component kinds cannot contain groups, assemblies, or models. (They ", {"text": ["can"], "type": "em"}, " contain subcomponent kinds)."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [31117, 31422], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, nodes that create/edit primitives have parameters to let you set the prim\u2019s kind. It does not allow you to use ", {"text": ["model"], "type": "code"}, " as a kind, in accordance with model hierarchy rules. Currently Houdini doesn\u2019t do anything to help or force the user to maintain the model hierarchy."]}], "indent": 0, "level": 3, "text": ["Kinds"], "extent": [29012, 29034], "container": true, "type": "h", "id": "kinds"}], "indent": 0, "level": 2, "text": ["Geometry in USD"], "extent": [28209, 28242], "container": true, "type": "h", "id": "geometry"}, {"body": [{"indent": 0, "type": "para", "extent": [31451, 31521], "text": ["There are various forms of \"instancing\" (efficient copying) in USD."]}, {"indent": 0, "type": "para", "extent": [31521, 31820], "text": ["USD inherently has the concept of one prim in the tree being a light-weight ", {"text": ["reference"], "type": "em"}, " to another. While this is more efficient than actually copying all the prims in the branch, to preserve the ability to override sub-prims, USD must also create references for each sub-prim under the reference."]}, {"indent": 0, "type": "para", "extent": [31820, 31969], "text": ["To get more efficient ways of populating the scene with large numbers of copies/variations of things, USD has two separate methods of ", {"text": ["instancing"], "type": "em"}, "."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [32036, 32164], "text": ["Prims have a bit of metadata that specifies that the prim is ", {"text": ["instanceable"], "type": "em"}, " (that is, \"can be considered for instancing\")."]}, {"indent": 4, "type": "para", "extent": [32164, 32574], "text": ["Whenever USD loads a prim that has ", {"text": ["instanceable = true"], "type": "code"}, ", it creates a virtual \"master\" copy of the primitive (and its descendants), and makes the instanceable prim a reference to this master primitive. Then, whenever USD encounters identical instanceable primitives in the scene graph, it automatically makes them pointers to the same master primitive, making \"duplicates\" take very little actual space."]}, {"indent": 4, "type": "para", "extent": [32574, 32830], "text": ["The trade-off is that you can\u2019t change any primitives under an instanceable prim. However, you can modify attributes on the instanceable prim itself. This lets you, for example, give each instance a unique transform, or set primvars used for shading."]}, {"indent": 4, "type": "para", "extent": [32830, 32970], "text": ["Further reading: [instancing|https://graphics.pixar.com/usd/docs/USD-Glossary.html|#USDGlossary-Instancing] in the Pixar USD glossary."]}], "indent": 0, "type": "dt", "extent": [31969, 32036], "text": ["\"Instance-able\" primitives (sometimes called \"native\" instancing)"]}, {"body": [{"indent": 4, "type": "para", "extent": [32988, 33274], "text": ["In a point instancer prim, each point in a geometry is replaced at view or render time by an instance of the geometry of one of the prims with a \"prototype\" relationship to the instancer. The point instancer prim stores mappings of points to primitives very efficiently in arrays."]}, {"indent": 4, "type": "para", "extent": [33274, 33533], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Houdini\u2019s instancing nodes support additional functionality beyond what USD\u2019s basic point instancer provides, similar to Houdini\u2019s own point instancing. These \"extra\" features are computed in the node and then \"baked\" into the USD."]}, {"indent": 4, "type": "para", "extent": [33533, 33663], "text": ["Further reading: ", {"text": [], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/api/class_usd_geom_point_instancer.html#details"}, " in the USD API docs."]}], "indent": 0, "type": "dt", "extent": [32970, 32988], "text": ["Point instancers"]}], "container": true, "type": "dt_group"}, {"indent": 0, "type": "para", "extent": [33663, 33972], "text": ["Instanceable prims are easier to work with than point instancers. However, while each \"alias\" consumes a very small amount of memory compared to copying the prim, it can add up over a very large number of instances. Point instancing is designed to handle ", {"text": ["billions"], "type": "em"}, " of instances, with constant memory usage."]}, {"indent": 0, "type": "para", "extent": [33972, 34201], "text": ["Both types of instances support transforming the top-level of each primitive and they also allow primvars (on each native instance individually, or on the point instancer primitive) to override material parameters per-instance."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [34207, 34348], "text": ["Do not directly instance ", {"fragment": "#geometry", "text": ["geometry prims"], "value": "#geometry", "fullpath": "/solaris/usd#geometry", "scheme": null, "type": "link"}, ". Instead, instance a prim above the actual geometry (such as its parent transform)."]}], "indent": 0, "role": "item", "type": "note", "extent": [34201, 34207]}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "extent": [34348, 34828], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Houdini supports both kinds of instancing with the ", {"text": ["Instancer"], "fullpath": "/nodes/lop/instancer", "scheme": "Node", "type": "link", "value": "/nodes/lop/instancer"}, " and various Tab menu tools that configure the instancer node for different ways of instancing, so you will choose the method of instancing mostly based on the number of instances needed. Houdini also supports ", {"text": ["nested point instancing"], "type": "em"}, " (one or more nested levels of instancers instancing prototypes containing instancers), and ", {"text": ["heroing"], "type": "em"}, " an instance to become a \"real\" model."]}], "indent": 0, "level": 2, "text": ["Instances"], "extent": [31422, 31451], "container": true, "type": "h", "id": "instancing"}, {"body": [{"indent": 0, "type": "para", "extent": [34854, 35162], "text": ["USD allows storing multiple named ", {"text": ["variants"], "type": "em"}, " of a primitive on the primitive. Each variant can have different attributes, relationships, and children. You can switch the primitive between different variants in different layers. Each primitive can store multiple groups of variants in named ", {"text": ["variant sets"], "type": "em"}, "."]}, {"indent": 0, "type": "para", "extent": [35162, 35217], "text": ["The following are some common use cases for variants:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [35217, 35328], "text": ["A family of different geometry (for example, a primitive that can switch between different types of trees)."]}, {"body": [{"indent": 4, "type": "para", "extent": [35479, 35618], "text": ["Houdini includes the ", {"text": ["Create LOD"], "fullpath": "/nodes/lop/createlod", "scheme": "Node", "type": "link", "value": "/nodes/lop/createlod"}, " and ", {"text": ["Auto Select LOD"], "fullpath": "/nodes/lop/autoselectlod", "scheme": "Node", "type": "link", "value": "/nodes/lop/autoselectlod"}, " nodes for automating this workflow."]}], "indent": 0, "text": ["Levels of detail (storing progressively lower resolution versions of the same geometry as variants, and switching based on distance to the camera)."], "extent": [35328, 35479], "blevel": 2, "type": "bullet"}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [35618, 35756], "text": ["Material assignments (storing variants with different materials assigned to them to allow switching the look of the primitive easily)."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [35756, 35875], "text": ["See ", {"text": ["Variant Set in Pixar USD glossary"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-VarientSet"}]}], "indent": 0, "level": 2, "text": ["Variants"], "extent": [34828, 34854], "container": true, "type": "h", "id": "variants"}, {"body": [{"indent": 0, "type": "para", "extent": [35898, 36036], "text": ["Animation in USD is through time-varying attribute values, similar to how animation in Houdini is through time-varying node parameters."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [36036, 36246], "text": ["Each attribute, besides have a single \"default\" value, can have an collection of \"time samples\", a list of values indexed by time. Metadata on the attribute specifies how to interpolate between the samples."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [36246, 36741], "text": ["If you ask USD for the value at the \"default\" time, it will return the default value if one is set, otherwise it will return an empty value. All time sample values are ignored.  If you ask for a value at any other time, and there is any default or time sampled value set, you will get back a value.  This value may be the default (if you request the value for a time before the first time sample), the closest time sample value, or a linear interpolation of the two surrounding time samples."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [36741, 36901], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " You can animate Houdini parameters on LOP nodes, and when you write out USD to disk, it will write the animated values as time samples."]}], "indent": 0, "level": 2, "text": ["Animation"], "extent": [35875, 35898], "container": true, "type": "h", "id": "time"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [37040, 37399], "text": ["At the \"tree\" level, USD is quite generic and \"free-form\". You can set attributes to arbitrary typed values directly. Schemas provide a way to enforce constraints and invariants. By using the higher-level API, you ensure that attributes are authored \"correctly\" (such as keeping values within a certain range, or not allowing impossible configurations)."]}], "indent": 0, "text": ["Schemas are custom extensions that can define new prim types or define the meaning/behavior of new attributes."], "extent": [36925, 37040], "blevel": 2, "type": "bullet"}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [37399, 37470], "text": ["USD calls a schema that defines its own prim type a ", {"text": ["typed schema"], "type": "em"}, "."]}, {"body": [{"indent": 4, "type": "para", "extent": [37643, 37726], "text": ["API schemas are further divided into ", {"text": ["singly-applied"], "type": "em"}, " and ", {"text": ["multiply-applied"], "type": "em"}, "."]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [37726, 37954], "text": ["An example of a singly-applied schema is ", {"text": ["UsdLuxShapingAPI"], "type": "code"}, ", where a light prim either has shaping controls added or not. Prims have metadata which records a list of all singly-applied API schemas that have been applied."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [37954, 38117], "text": ["An example of a multiply-applied schema is the ", {"text": ["CollectionAPI"], "type": "code"}, ". You can define as many uniquely named ", {"text": ["collection:"], "type": "code"}, " attributes on a given prim as you want."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["USD calls a schema that just defines an API you can apply on top of prims of different types an ", {"text": ["API schema"], "type": "em"}, ". This type of schema generally have names that end in ", {"text": ["API"], "type": "code"}, "."], "extent": [37470, 37643], "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [38117, 38541], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " Houdini generally doesn\u2019t use custom attributes. Instead it often stores information in a \"custom data\" dictionary in the metadata of a prim. This space is intended for use by software packages and studios for their own use. Houdini stores bookkeeping information here that helps with saving USD to disk or navigating the scene, but this custom data is usually stripped from the USD written to disk."]}], "indent": 0, "level": 2, "text": ["Schemas"], "extent": [36901, 36925], "container": true, "type": "h", "id": "schemas"}, {"body": [{"indent": 0, "type": "para", "extent": [38577, 38817], "text": ["USD defines an API (called Hydra) for generating an image from a USD scene at a certain point in time. As long as a program (such as Houdini, or ", {"text": ["usdview"], "type": "code"}, ", or a renderer) implements this API, it can be used to display/render a USD scene."]}, {"indent": 0, "type": "para", "extent": [38817, 38894], "text": ["A piece of software that implements this API is called a ", {"text": ["render delegate"], "type": "em"}, "."]}, {"indent": 0, "type": "para", "extent": [38894, 39293], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini this has the great benefit that you can ", {"text": ["switch the scene view"], "fullpath": "/solaris/view", "scheme": null, "type": "link", "value": "/solaris/view"}, " between available render delegates such as Houdini\u2019s OpenGL viewer, Pixar\u2019s Storm OpenGL viewer, and Karma IPR. Further, you can view the scene using ", {"text": ["any third-party renderer"], "type": "em"}, " that has implemented the Hydra API. They don\u2019t need to do extra work to integrate specifically with Houdini."]}], "indent": 0, "level": 2, "text": ["Hyrdra and rendering"], "extent": [38541, 38577], "container": true, "type": "h", "id": "render"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [39325, 39659], "text": ["Commonly, the \"top-level\" USD file will represent a ", {"text": ["shot"], "type": "em"}, ". In a studio, the top-level file will usually reference in files broken down by ", {"text": ["department"], "type": "em"}, " (characters, set/props, lights) which have their own references to individual assets. In a smaller or one-person environment, the top-level file might directly reference assets."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [39659, 39988], "text": ["It\u2019s not useful to look at USD reference depth as a measure of \"slowness\" (or complexity). USD\u2019s composition engine is quite fast. Performance (such as load time) depends more on what is in the layers, and your infrastructure (such as loading files locally or over the network), than how many levels of references there are."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Organizing USD"], "extent": [39293, 39325], "container": true, "type": "h", "id": "organize"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [40006, 40091], "text": ["In USD documentation, they sometimes refer to the scene tree as the ", {"text": ["namespace"], "type": "em"}, "."]}, {"body": [{"indent": 4, "type": "para", "extent": [40168, 40329], "text": ["Relative path references (for example ", {"text": ["./chair.usd"], "type": "code"}, ") are relative to the layer file containing the reference (for example ", {"text": ["/Users/Aisha/Work/kitchen.usd"], "type": "code"}, ")."]}, {"indent": 4, "type": "para", "extent": [40329, 40492], "text": ["For large studios or complex file management cases, it\u2019s probably better to use ", {"fragment": "#extend", "text": ["asset IDs and a custom resolver"], "value": "#extend", "fullpath": "/solaris/usd#extend", "scheme": null, "type": "link"}, " than to use complicated file paths."]}, {"indent": 4, "type": "para", "extent": [40492, 40859], "text": [{"text": "", "fullpath": "/solaris/MISC/logo", "scheme": "Smallicon", "type": "link", "value": "MISC/logo"}, " In Houdini, you will usually store files relative to the scene file (", {"text": ["$HIP/..."], "type": "code"}, "). When Houdini writes out USD, it calls ", {"fragment": "#processors", "text": ["output processors"], "value": "/solaris/output#processors", "fullpath": "/solaris/output#processors", "scheme": null, "type": "link"}, " to translate file paths. The default output process translates file paths relative to ", {"text": ["$HIP"], "type": "code"}, " into paths relative to the top-level USD file, in line with USD\u2019s conventions."]}], "indent": 0, "text": ["Avoid using absolute file paths, and use forward slashes even on Windows."], "extent": [40091, 40168], "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Tips"], "extent": [39988, 40006], "container": true, "type": "h", "id": "tips"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [40881, 40975], "text": [{"text": ["Introduction to USD (Pixar)"], "scheme": null, "type": "link", "exists": true, "value": "http://graphics.pixar.com/usd/docs/Introduction-to-USD.html"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [40975, 41054], "text": [{"text": ["USD glossary (Pixar)"], "scheme": null, "type": "link", "exists": true, "value": "http://graphics.pixar.com/usd/docs/USD-Glossary.html"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [41054, 41175], "text": [{"text": ["USD frequently asked questions (Pixar)"], "scheme": null, "type": "link", "exists": true, "value": "https://graphics.pixar.com/usd/docs/USD-Frequently-Asked-Questions.html"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Further reading"], "extent": [40859, 40881], "container": true, "type": "h", "id": null}], "summary": ["Introduces a number of USD concepts, and how they relate to Houdini\u2019s USD support."], "type": "root", "attrs": {}, "title": ["USD Basics"]}